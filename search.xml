<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用Docker和angular5及Koa创建MEAN应用]]></title>
    <url>%2F2017%2F12%2F18%2F%E7%94%A8Docker%E5%92%8Cangular5%E5%8F%8AKoa%E5%88%9B%E5%BB%BAMEAN%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先要确保angualr-cli和docker都已经安装完毕。 client创建一个新的angular-cli项目mean-docker/angular-client。 在angular-client目录下，创建一个Dockerfile，并写入如下内容123456789101112131415FROM node:8# 创建工作目录RUN mkdir -p /usr/src/app# 切换到工作目录WORKDIR /usr/src/app# 拷贝package.json到工作目录COPY package.json /usr/src/app# 运行npm installRUN npm install# 拷贝所有source到工作目录COPY . /usr/src/app# 开放4200端口EXPOSE 4200# 运行npm startCMD [&quot;npm&quot;, &quot;start&quot;] 为了防止node_modules文件夹也被拷贝，可以新建一个.dockeringore文件把它过滤掉。 为了确保client端由docker image提供host，需要修改package.json中npm start一节为：1&quot;start&quot;: &quot;ng serve -H 0.0.0.0&quot;, 接下来，build这个镜像：1docker build -t angular-client:dev . bulid好镜像之后，可以使用这个镜像来创建容器：1docker run -d --name angular-client -p 4200:4200 angular-client:dev server在mean-docker目录下创建一个koa-server目录。执行npm init命令，新建一个npm 项目。安装koa和koa-router等组件。 app.js中写入如下内容：123456789101112131415161718192021222324252627282930const compose = require('koa-compose');const Koa = require('koa');const app = new Koa();const router = require('./router');// x-response-timeasync function responseTime (ctx, next)&#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`);&#125;;// loggerasync function logger (ctx, next) &#123; const start = Date.now(); await next(); const ms = Date.now() - start; console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;`);&#125;;const all = compose([ responseTime, logger(), router.routes()]);app.use(all);app.listen(3000); router中写入如下内容：1234567const router = require('koa-router')();router.get('/', (ctx, next) =&gt; &#123; ctx.body = 'api works';&#125;);module.exports = router; 在koa-server目录下，创建一个Dockerfile，并写入如下内容：12345678FROM node:6RUN mkdir -p /usr/src/appWORKDIR /usr/src/appCOPY package.json /usr/src/appRUN npm installCOPY . /usr/src/appEXPOSE 3000CMD [&quot;npm&quot;, &quot;start&quot;] 同样的，也需要添加一个.dockeringore来忽略node_modules。为package.json添加npm start命令1&quot;start&quot;: &quot;node app.js&quot;, 执行docker build和docker run12docker build -t koa-server:dev .docker run -d --name koa-server -p 3000:3000 koa-server:dev mongodb启动一个mongodb容器：1docker run -d --name mongodb -p 27017:27017 mongo compose123456789101112131415services: angular: build: angular-client ports: - "4200:4200" koa: build: koa-server ports: - "3000:3000" database: image: mongo ports: - "27017:27017" 至此，三个容器就创建好了，接下来补充程序中的实质性内容： server端内容补充首先安装mongoose，为router添加路由和mongoose组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// User modelconst db = 'mongodb://database/mean-docker';mongoose.connect(db);const userSchema = new mongoose.Schema(&#123; name: String, age: Number&#125;);const User = mongoose.model('User', userSchema);// ...router.get('/users',async (ctx, next) =&gt; &#123; await User.find(&#123;&#125;, (err, users) =&gt; &#123; if (err) &#123; ctx.status = 500; ctx.body = err; &#125;else&#123; ctx.status = 200; ctx.body = users; &#125; &#125;);&#125;);/* GET one users. */router.get('/users/:id',async (ctx, next) =&gt; &#123; await User.findById(ctx.request.param.id, (err, users) =&gt; &#123; if (err) &#123; ctx.status = 500; ctx.body = err; &#125;else&#123; ctx.status = 200; ctx.body = users; &#125; &#125;);&#125;);/* Create a user. */router.post('/users',async (ctx, next) =&gt; &#123; let user = new User(&#123; name: ctx.request.body.name, age: ctx.request.body.age &#125;); await user.save(error =&gt; &#123; if (error) &#123; ctx.status = 500; ctx.body = error; &#125;else&#123; ctx.status = 200; ctx.body = &#123; message: 'User created successfully' &#125;; &#125; &#125;);&#125;); 接下来，连接mongodb和koa-server，在docker-compose中koa-server一节增加这样一句：12links: - database 前端内容补充在app.component.ts中添加如下内容：123456789101112131415161718192021222324252627282930313233// ...// Link to our api, pointing to localhostAPI = 'http://localhost:3000';// Declare empty list of peoplepeople: any[] = [];constructor(private http: Http) &#123;&#125;// Angular 2 Life Cycle event when component has been initializedngOnInit() &#123; this.getAllPeople();&#125;// Add one person to the APIaddPerson(name, age) &#123; this.http.post(`$&#123;this.API&#125;/users`, &#123;name, age&#125;) .map(res =&gt; res.json()) .subscribe(() =&gt; &#123; this.getAllPeople(); &#125;)&#125;// Get all users from the APIgetAllPeople() &#123; this.http.get(`$&#123;this.API&#125;/users`) .map(res =&gt; res.json()) .subscribe(people =&gt; &#123; console.log(people) this.people = people &#125;)&#125;// ... 在app.component.html中增加如下内容：12345678910111213141516171819202122&lt;div class="container"&gt; &lt;div [style.margin-top.px]="10" class="row"&gt; &lt;h3&gt;Add new person&lt;/h3&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control" id="name" #name&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="age"&gt;Age&lt;/label&gt; &lt;input type="number" class="form-control" id="age" #age&gt; &lt;/div&gt; &lt;button type="button" (click)="addPerson(name.value, age.value)" class="btn btn-primary"&gt;Add person&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div [style.margin-top.px]="10" class="row"&gt; &lt;h3&gt;People&lt;/h3&gt; &lt;div [style.margin-right.px]="10" class="card card-block col-md-3" *ngFor="let person of people"&gt; &lt;h4 class="card-title"&gt;&#123;&#123;person.name&#125;&#125; &#123;&#123;person.age&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这样，就可以添加用户，查看用户了。]]></content>
      <categories>
        <category>全栈</category>
        <category>MEAN</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>nodejs</tag>
        <tag>全栈</tag>
        <tag>mongodb</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis常用命令]]></title>
    <url>%2F2017%2F11%2F20%2FRedis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[String 命令 解释 INCR key 增加值+1 DECR key 减少值-1 MSET 一次set多个值 MGET 一次get多个值 INCRBY key 按参数增加值 DECRBY key 按参数减少值 APPEND key value 拼接字符串 GETRANGE key offset 截取字符串 SETRANGE key offset value 按位置更改字符串 STRLEN key 获取键对应的值的长度 SETBIT key offset value 设置或者清空key的value(字符串)在offset处的bit值 GETBIT key offset 获得key的value(字符串)在offset处的bit值 BITCOUNT key start end 统计字符串的二级制码中，有多少个’1’ List 命令 解释 RPUSH(LPUSH) key value 从右端向key插入值 LRANGE key start stop 按范围返回值 LINDEX key index 按索引返回值 RPOP(LPOP) 从右侧弹出一个值 LTRIM key start stop 按范围从左侧删除值 BRPOP(BLPOP) key [key …] timeout 阻塞式从右侧弹出值，有多个key时，从key的左边向右边遍历弹出值，直到没有值可以被弹出 RPOPLPUSH source destination 原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部） Set 命令 解释 SADD key member [member…] 添加一个或多个元素 SMEMBERS key 获得key的所有值 SISMEMBER key member 判断一个member在不在set中 SREM key member [member…] 删除一个或多个member SCARD key 获取集合中元素数量 SPOP key [count] 随机弹出一个或多个元素 SRANDMEMBER key [count] 返回一个或多个元素 SMOVE source destination member 把一个元素从一个set移动到另一个set SDIFF 求两个set的差集 SDIFFSTORE 求两个set的差集并保存 SINTER 求两个set的交集 SINTERSTORE 求两个set的交集并保存 SUNION 求两个set的并集 SUNIONSTORE 求两个set的并集并保存 Hash 命令 解释 HSET key field value 添加一个hash HDEL key field [field …] 删除一个或多个键值 HGET key field 获得key下面field键的值 HGETALL key 返回key下面所有的键值对 HKEYS key 返回key下面所有的键 HVALS key 返回key下面所有的值 HINCRBY key field increment key下面field的值增加1 HLEN key 返回key下面值键值对的数量 HMSET key field value [field value…] 添加多个hash HEXISTS key field 判断一个key是否在hash内 Zset 命令 解释 ZRANGE key start stop [WITHSCORES] 根据指定的index返回，返回sorted set的成员列表 ZRANGEBYSCORE key min max [WITHSCORES] 返回有序集合中指定分数区间内的成员，分数由低到高排序 ZREM key member [member…] 从排序的集合中删除一个或多个成员 ZINCRBY key increment member 增加一名成员的评分 ZCOUNT key min max 返回分数范围内的成员数量 ZRANK key member 返回成员在集合中的索引 ZSCORE key member 返回成员的得分 ZREVRANK key member 返回分数从高到低的成员的排名 ZREVRANGE key start stop [WITHSCORES] 返回成员的范围，分数从高到低排序 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] 按照分数从大到小返回范围元素，可以增加limit进行数量限制 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 按照分数从小到大返回范围元素，可以增加limit进行数量限制 ZADD key [NX or XX] [CH] [INCR] score member [score member …] 将所有指定成员添加到键为key有序集合（sorted set）里面 ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM or MIN orMAX] 计算交集，并把结果放到destination中 ZUNIONSCORE 计算并集，并把结果放到destination中 ZRANGEBYLEX key min max [LIMIT offset count] 返回指定成员区间内的成员，按字典正序排列 ZREM key member [member …] 删除一个或多个成员]]></content>
      <categories>
        <category>后端</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云乞丐版折腾ebookcoin]]></title>
    <url>%2F2017%2F02%2F10%2F%E9%98%BF%E9%87%8C%E4%BA%91%E4%B9%9E%E4%B8%90%E7%89%88%E6%8A%98%E8%85%BEebookcoin%2F</url>
    <content type="text"><![CDATA[阿里云除了ECS外，今年还推出了轻量应用服务器。主要用来部署个人应用，小网站后台，我也申请了一个来玩，三个月135元。 大多数云主机，比如aws，都是没有图形画面的，在网页控制台只能使用简陋的交互式终端来操作。 我的目的是在GUI下，用VSCode调试区块链程序-Ebookcoin（亿书）。从一无所有的云服务器中建立调试环境，主要有以下几个步骤： 建立桌面（vncviewer)到云服务器间的连接（vncserver） 在云服务器上安装，配置GUI环境 安装git，VSCode等 建立桌面（vncviewer)到云服务器间的连接（vncserver）首先，要在阿里云防火墙中打开5901和5902端口，否则后面桌面端无法访问。 在远程连接中安装vncserver，执行：12sudo apt-get updatesudo apt-get install vnc4server 然后执行，启动服务，输入访问密码1vncserver 在vncviewer中输入公网IP:1即可访问。 在云服务器上安装，配置GUI环境阿里云官方推荐的gnome，ubuntu-desktop图形环境很大，对乞丐版20GB的空间太大，所以换成不足300MB的xfce4。在远程连接中安装xfce4，执行：1sudo apt-get install xfce4 因为要在vncviewer中运行GUI，所以不能简单通过startx来运行，需要配置xstartup，末尾添加12345sesion-manager &amp; xfdesktop &amp; xfce4-panel &amp;xfce4-menu-plugin &amp;xfsettingsd &amp;xfconfd &amp;xfwm4 &amp; 网上很多文章都说：注释掉x-window-manager，但是如果注释掉这一句会导致阿里云浏览器端控制台无法打开，保留并不会影响任何功能。 重新启动vncserver即可。1234vncserver -kill :1vncserver// 带图形参数启动vncserver -geometry 1280x1024 -depth 16:1 vncviewer重新连接，xfce4就出来了。 xfce4默认情况下，两个问题的解决方法： Tab失效：修改快捷键设置-Switch window for same application sudo时消除unable to resolve host，在host内增加阿里云主机名，也就是那一长串英文安装git，安装vscode123sudo apt-get install gitwget https://vscode.cdn.azure.cn/stable/0759f77bb8d86658bc935a10a64f6182c5a1eeba/code_1.19.1-1513676564_amd64.debsudo dpkg -i code_1.19.1-1513676564_amd64.deb VSCode无法启动时，根据github讨论的结果，可以使用如下方法：12sudo sed -i &apos;s/BIG-REQUESTS/_IG-REQUESTS/&apos; /usr/share/code/libxcb.so.1sudo sed -i &apos;s/BIG-REQUESTS/_IG-REQUESTS/&apos; /usr/share/code/libxcb.so.1.1.0 调试ebookcoin现在，基本工具已经具备，开始安装调试工具。 安装nodejs到桌面文件夹apps中 123456789101112wget https://nodejs.org/dist/v8.9.3/node-v8.9.3-linux-x64.tar.xzxz -d node-v8.9.3-linux-x64.tar.xzmkdir appstar -xvf node-v8.9.3-linux-x64.tarmv node-v8.9.3-linux-x64 nodemv node apps// 添加pathexport NODE_HOME=/home/admin/Desktop/nodeexport PATH=$PATH:$NODE_HOME/bin export NODE_PATH=$NODE_HOME/lib/node_modules// /root/.bashrc内添加生效source /etc/profile Clone代码 1234git clone https://github.com/Ebookcoin/ebookcoin.git// 使用SSH连接github后，clone submodulegit submodule initgit submodule update 构建代码 123456789101112// 安装依赖包cd ebookcoinnpm install// 全局安装 grunt-cli:npm install grunt-cli -g// 全局安装 bower:npm install bower -g// 构建前台cd publicnpm installbower installgrunt release 运行直接在app.js中进行vscode debug，区块链程序已经跑起来了。]]></content>
      <categories>
        <category>后端</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>nodejs</tag>
        <tag>区块链</tag>
        <tag>ebookcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143行js顶部进度条最小插件-nanobar.js源码解析]]></title>
    <url>%2F2017%2F02%2F07%2FNanoBar%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[网页顶部进度条插件的有四五种，基本原理就是动态地创建一个元素，然后通过设置它的width来实现动画效果，width增长到达指定位置时，将其去掉。来看看nanobar.js作者jacoborus是怎么做到的吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* http://nanobar.micronube.com/ || https://github.com/jacoborus/nanobar/ MIT LICENSE */(function (root) &#123; 'use strict' // container styles var css = '.nanobar&#123;width:100%;height:4px;z-index:9999;top:0&#125;.bar&#123;width:0;height:100%;transition:height .3s;background:#000&#125;' // add required css in head div function addCss () &#123; var s = document.getElementById('nanobarcss') // check whether style tag is already inserted if (s === null) &#123; s = document.createElement('style') s.type = 'text/css' s.id = 'nanobarcss' document.head.insertBefore(s, document.head.firstChild) // the world if (!s.styleSheet) return s.appendChild(document.createTextNode(css)) // IE s.styleSheet.cssText = css &#125; &#125; function addClass (el, cls) &#123; if (el.classList) el.classList.add(cls) else el.className += ' ' + cls &#125; // create a progress bar // this will be destroyed after reaching 100% progress function createBar (rm) &#123; // create progress element var el = document.createElement('div'), width = 0, here = 0, on = 0, bar = &#123; el: el, go: go &#125; addClass(el, 'bar') // animation loop function move () &#123; var dist = width - here if (dist &lt; 0.1 &amp;&amp; dist &gt; -0.1) &#123; place(here) on = 0 if (width === 100) &#123; el.style.height = 0 setTimeout(function () &#123; rm(el) &#125;, 300) &#125; &#125; else &#123; place(width - dist / 4) setTimeout(go, 16) &#125; &#125; // set bar width function place (num) &#123; width = num el.style.width = width + '%' &#125; function go (num) &#123; if (num &gt;= 0) &#123; here = num if (!on) &#123; on = 1 move() &#125; &#125; else if (on) &#123; move() &#125; &#125; return bar &#125; function Nanobar (opts) &#123; opts = opts || &#123;&#125; // set options var el = document.createElement('div'), applyGo, nanobar = &#123; el: el, go: function (p) &#123; // expand bar applyGo(p) // create new bar when progress reaches 100% if (p === 100) &#123; init() &#125; &#125; &#125; // remove element from nanobar container function rm (child) &#123; el.removeChild(child) &#125; // create and insert progress var in nanobar container function init () &#123; var bar = createBar(rm) el.appendChild(bar.el) applyGo = bar.go &#125; addCss() addClass(el, 'nanobar') if (opts.id) el.id = opts.id if (opts.classname) addClass(el, opts.classname) // insert container if (opts.target) &#123; // inside a div el.style.position = 'relative' opts.target.insertBefore(el, opts.target.firstChild) &#125; else &#123; // on top of the page el.style.position = 'fixed' document.getElementsByTagName('body')[0].appendChild(el) &#125; init() return nanobar &#125; if (typeof exports === 'object') &#123; // CommonJS module.exports = Nanobar &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], function () &#123; return Nanobar &#125;) &#125; else &#123; // Browser globals root.Nanobar = Nanobar &#125;&#125;(this)) 大体看下来，这个插件有这样几个特点： dom+js原生选择器 支持模块化 es5+IIFE 不用分号派 详细来看：在程序的开头，定义了必要的Css属性，包括bar（主体）和Nanobar（容器）两个class：123456789101112.nanobar&#123;width:100%;height:4px;z-index:9999;top:0&#125;.bar&#123;width:0;height:100%;transition:height .3s;background:#000&#125; 从css内容来看，仅有.bar有transition:height .3s的过渡设置，height过渡发生的时间应该是被删除时。在横向应该是没有动画效果，但是从官网演示效果来看，横向仍然有一定的动画效果，这个问题下面会提到。 另外，引用作者原话： Nanobar injects a style tag in your HTML head. Bar divs has class .bar, and its containers .nanobar, so you can overwrite its values. You should know what to do with that ;) 然后来看构造函数NanoBar：NanoBar接受一个opts作为参数，文档记载的opts详细内容如下： 名称 功能 id 指定nanobar的id classname 指定nanobar的class target 指定Nanobar的表示位置，一般对于做顶部进度条来说不到。值得一提的是，这个参数类型为DOM Element，你必须使用document.getxxxxx之类的方法为其赋值。 首先声明了三个变量： 名称 描述 el 这就是动态创建的元素-一个既没有ID也没有Class的空div applyGo 进度条移动的方法 nanobar nanobar对象，它将在new构造函数时作为结果返回 其中，nanobar包含这两个元素： 名称 描述 el 上面动态创建的元素 go 对外开放的方法，参数为数值，那么它肯定代表了百分比而不是像素等实际物理单位 此处的go处理内实质上调用的是applyGo，而applyGo此时肯定为undefined，所以applyGo实际上在别处赋值。这样处理的结果，相当于是一层封装，隐藏了内部实际的go方法内容。 另外也可以猜测，nanobar的最简单的使用方法如下：12var nanobar = new Nanobar();nanobar.go(80); 接下来，声明了两个内部函数，这两个内部函数可以访问上面提到的三个变量： 名称 作用 rm 用于进度完成后，删除动态创建的元素 init 初始化方法，这个需要重点关注 然后是一些必要处理，由这三个部分组成： addCss方法，为head节点内增加&lt;style id=&quot;nanobarcss&quot;&gt;节点，并把上文的css填入其中。 调用addClass方法，创建类名为nanobar的容器。需要注意的是，相比于直接操作className方法内调用了HTML5的新APIclassList，使用它可以像jquery的addClass、removeClass一样方便的对dom对象的class进行增加删除判断。更多信息请看这里。 接下来是对opts参数进行处理：主要是为el元素赋予id和className，根据是否指定了父容器，也就是target，改变容器的position，并且最终将它插入到对应的位置上。 接着来看init()方法：前面所有的操作，创建了一个名为nanobar的容器，接下来就该创建bar主体了。 可以看到，bar变量内仍然和nanobar一样，由el和go两部分组成，go最终将被赋值到外层容器的applyGo，el将被作为子元素插入到外层容器的el内。 这样，当用最简单的方式调用go时，它的顺序就是这样的： 容器nanobar.go-&gt;applyGo-&gt;本体bar.go 那么调用了go方法后，为什么横向会有一定的动画效果呢？观察一下nanobar的动作方法go、move、place 其中的控制量有这么几个： 名称 作用 on 相当于布尔flag，标识了进度是否完成了 here 终点位置 dist 与终点相比的距离 实际处理流程可以这样表示： 12place(width - dist / 4) -&gt; dist &lt; 0.1-&gt; dist = width -here -&gt; 高度置零，删除元素 形成动画的根本原因则是这么两个原因： 方法place(width - dist / 4)对剩余空间的细分 第58紧随其后的setTimeout(go,16)，假设把x轴看成是16ms，把Y轴看成是每次细分的长度，将会得到一个图像类似于log2x(前期趋势大，后期趋势平稳，类似于动画函数中的ease-out)的表达式。中学都学过，就不再赘述了。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>源码</tag>
        <tag>dom</tag>
        <tag>nanobar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelizejs中数据查询的方法]]></title>
    <url>%2F2017%2F01%2F22%2Fsequelizejs%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Raw query 最简单的查询123sequelize.query("SELECT * FROM myTable").then(myTableRows =&gt; &#123; console.log(myTableRows)&#125;) Map to model 123456sequelize .query('SELECT * FROM projects', &#123; model: Projects &#125;) .then(projects =&gt; &#123; // Each record will now be mapped to the project's model. console.log(projects) &#125;) Options 12345678910111213sequelize .query('SELECT 1', &#123; // 可以设为false或者console logging: console.log, // 是否只返回结果集中的第一行 plain: false, // 如果没有model可以映射，设为false raw: false, // 设置了queryType后，可以改变返回结果的形式 type: Sequelize.QueryTypes.SELECT &#125;) 参数查询 12345678sequelize.query( 'SELECT * FROM projects WHERE status = ?', &#123; raw: true, replacements: ['active']).then(projects =&gt; &#123; console.log(projects)&#125;) Model Query findById 1234Project.findById(123).then(project =&gt; &#123; // project will be an instance of Project and stores the content of the table entry // with id 123. if such an entry is not defined you will get null&#125;) findByAttribute 1234// search for attributesProject.findOne(&#123; where: &#123;title: 'aProject'&#125; &#125;).then(project =&gt; &#123; // project will be the first entry of the Projects table with the title 'aProject' || null&#125;) findOrCreate 相当于mongodb的upsert 1234567User .findOrCreate(&#123;where: &#123;username: 'sdepold'&#125;, defaults: &#123;job: 'Technical Lead JavaScript'&#125;&#125;) .spread((user, created) =&gt; &#123; // 返回object和boolean console.log(user.get(&#123; plain: true &#125;)) console.log(created) findAndCountAll对结果集进行偏移或约束 12345678910Project .findAndCountAll(&#123; where: &#123; title: &#123; [Op.like]: 'foo%' &#125; &#125;, offset: 10, limit: 2 &#125;) findAll约束： 1User.findAll(&#123; offset: 10, limit: 2 , order: 'title DESC', group: 'name'); 操作符,这些操作符也可以进一步组合 12345678910111213141516171819[Op.and]: &#123;a: 5&#125;, // AND (a = 5)[Op.or]: [&#123;a: 5&#125;, &#123;a: 6&#125;], // (a = 5 OR a = 6)[Op.gt]: 6, // id &gt; 6[Op.gte]: 6, // id &gt;= 6[Op.lt]: 10, // id &lt; 10[Op.lte]: 10, // id &lt;= 10[Op.ne]: 20, // id != 20[Op.between]: [6, 10], // BETWEEN 6 AND 10[Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15[Op.in]: [1, 2], // IN [1, 2][Op.notIn]: [1, 2], // NOT IN [1, 2][Op.like]: '%hat', // LIKE '%hat'[Op.notLike]: '%hat', // NOT LIKE '%hat'[Op.iLike]: '%hat', // ILIKE '%hat' (case insensitive) (PG only)[Op.notILike]: '%hat', // NOT ILIKE '%hat' (PG only)[Op.overlap]: [1, 2], // &amp;&amp; [1, 2] (PG array overlap operator)[Op.contains]: [1, 2], // @&gt; [1, 2] (PG array contains operator)[Op.contained]: [1, 2], // &lt;@ [1, 2] (PG array contained by operator)[Op.any]: [2,3] // ANY ARRAY[2, 3]::INTEGER (PG only)]]></content>
      <categories>
        <category>后端</category>
        <category>sequelizejs</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>后端</tag>
        <tag>sequelizejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelizejs中关系数据的表示]]></title>
    <url>%2F2017%2F01%2F22%2Fsequelizejs%E4%B8%AD%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[外键的四种写法 user将会添加一个companyId属性，参照Company的主键id1234const User = this.sequelize.define('user', &#123;/* attributes */&#125;)const Company = this.sequelize.define('company', &#123;/* attributes */&#125;);User.belongsTo(Company); 添加company_uuid到user作为user的外键 123456789const User = this.sequelize.define('user', &#123;/* attributes */&#125;, &#123;underscored: true&#125;)const Company = this.sequelize.define('company', &#123; uuid: &#123; type: Sequelize.UUID, primaryKey: true &#125;&#125;);User.belongsTo(Company); 添加roleId to user而不是userRoleId 1234const User = this.sequelize.define('user', &#123;/* attributes */&#125;)const UserRole = this.sequelize.define('userRole', &#123;/* attributes */&#125;);User.belongsTo(UserRole, &#123;as: 'role'&#125;); 直接指定外键名 1234const User = this.sequelize.define('user', &#123;/* attributes */&#125;)const Company = this.sequelize.define('company', &#123;/* attributes */&#125;);// 对source添加User.belongsTo(Company, &#123;foreignKey: 'fk_company'&#125;); // Adds fk_company to User one-to-one关系12345const User = sequelize.define('user', &#123;/* ... */&#125;)const Project = sequelize.define('project', &#123;/* ... */&#125;)// One-way associationsProject.hasOne(User) // 会对User添加projectId属性，作为User的外键，它将关联Project的主键 many-to-one关系12345const User = sequelize.define('user', &#123;/* ... */&#125;)const Project = sequelize.define('project', &#123;/* ... */&#125;)// First let's define a hasMany associationProject.hasMany(User, &#123;as: 'Workers'&#125;) // 添加projectId到User,并且为Project的实例会添加getWorkers和SetWorkers两个方法 one-to-many关系 ON UPDATE CASCADE ON DELETE CASCADE12Project.belongsToMany(User, &#123;through: 'UserProject'&#125;); // through内写model define的名字，而不是变量名，例如Userdefine时写成user，就写userUser.belongsToMany(Project, &#123;through: 'UserProject'&#125;); // userproject,它将关联外键projectid和userId。并且project会添加hasUser,setUser,setUsers,getUser,getUsers方法，User也会得到对应的set,get方法 也可以直接在model定义时定义外键]]></content>
      <categories>
        <category>后端</category>
        <category>sequelizejs</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>后端</tag>
        <tag>sequelizejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelizejs中数据持久化的方法]]></title>
    <url>%2F2017%2F01%2F21%2Fsequelizejs%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[sync只能用来建表 save123456789Task .build(&#123; title: 'foo', description: 'bar', deadline: new Date() &#125;) .save() .then(anotherTask =&gt; &#123; // you can now access the currently saved task with the variable anotherTask... nice! &#125;) .catch(error =&gt; &#123; // Ooops, do some error-handling &#125;) create 相当于结合了build和save123Task.create(&#123; title: 'foo', description: 'bar', deadline: new Date() &#125;).then(task =&gt; &#123; // you can now access the newly created task via the variable task&#125;) 多条create123456789User.bulkCreate([ &#123; username: 'barfooz', isAdmin: true &#125;, &#123; username: 'foo', isAdmin: true &#125;, &#123; username: 'bar', isAdmin: false &#125;]).then(() =&gt; &#123; // Notice: There are no arguments here, as of right now you'll have to... return User.findAll();&#125;).then(users =&gt; &#123; console.log(users) // ... in order to get the array of user objects&#125;) update的三种形式1234567891011121314151617task.save(&#123;fields: ['title']&#125;).then(() =&gt; &#123; // title will now be 'foooo' but description is the very same as before&#125;)// The equivalent call using update looks like this:task.update(&#123; title: 'foooo', description: 'baaaaaar'&#125;, &#123;fields: ['title']&#125;).then(() =&gt; &#123; // title will now be 'foooo' but description is the very same as before&#125;)// 先查出来，然后reloadPerson.findOne(&#123; where: &#123; name: 'john' &#125; &#125;).then(person =&gt; &#123; person.name = 'jane' console.log(person.name) // 'jane' person.reload().then(() =&gt; &#123; console.log(person.name) // 'john' &#125;)&#125;) delete1task.destroy(&#123;force: true&#125;)]]></content>
      <categories>
        <category>后端</category>
        <category>sequelizejs</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>后端</tag>
        <tag>sequelizejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelizejs中model定义方法]]></title>
    <url>%2F2017%2F01%2F21%2Fsequelizejs%E4%B8%ADmodel%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以下是对sequelize.define方法的详解： 可以为define方法添加getter,setter 123456789101112131415161718192021const Employee = sequelize.define('employee', &#123; name: &#123; type: Sequelize.STRING, allowNull: false, // 字段内的get方法 get() &#123; const title = this.getDataValue('title'); return this.getDataValue('name') + ' (' + title + ')'; // this.getDataValue是内建的help方法，用来取得字段的值 &#125;, &#125;, title: &#123; type: Sequelize.STRING, allowNull: false, // 字段内的set方法 set(val) &#123; this.setDataValue('title', val.toUpperCase()); // 同上 &#125; &#125;&#125;); 如果要后台检验值时，可以使用model内的validations12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// msg属性可以作为错误信息传递到前台const ValidateMe = sequelize.define('foo', &#123; foo: &#123; type: Sequelize.STRING, validate: &#123; is: ["^[a-z]+$",'i'], // will only allow letters is: /^[a-z]+$/i, // same as the previous example using real RegExp not: ["[a-z]",'i'], // will not allow letters isEmail: true, // checks for email format (foo@bar.com) isUrl: true, // checks for url format (http://foo.com) isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format isIPv4: true, // checks for IPv4 (129.89.23.1) isIPv6: true, // checks for IPv6 format isAlpha: true, // will only allow letters isAlphanumeric: true, // will only allow alphanumeric characters, so "_abc" will fail isNumeric: true, // will only allow numbers isInt: true, // checks for valid integers isFloat: true, // checks for valid floating point numbers isDecimal: true, // checks for any numbers isLowercase: true, // checks for lowercase isUppercase: true, // checks for uppercase notNull: true, // won't allow null isNull: true, // only allows null notEmpty: true, // don't allow empty strings equals: 'specific value', // only allow a specific value contains: 'foo', // force specific substrings notIn: [['foo', 'bar']], // check the value is not one of these isIn: [['foo', 'bar']], // check the value is one of these notContains: 'bar', // don't allow specific substrings len: [2,10], // only allow values with length between 2 and 10 isUUID: 4, // only allow uuids isDate: true, // only allow date strings isAfter: "2011-11-05", // only allow date strings after a specific date isBefore: "2011-11-05", // only allow date strings before a specific date max: 23, // only allow values &lt;= 23 min: 23, // only allow values &gt;= 23 isCreditCard: true, // check for valid credit card numbers // custom validations are also possible: isEven(value) &#123; if (parseInt(value) % 2 != 0) &#123; throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed &#125; &#125; &#125; &#125;&#125;); 可以在表结构上附加Options123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; // 不需要updatedAt, createdAt时填false timestamps: false, // 在删除操作时，并不真正删除，而是设置deletedAt字段。必须和timestamps连用 paranoid: true, // 新加入的字段，例如updatedAt，由驼峰式改为下划线式，updated_at underscored: true, // 禁止自动更改表名，用默认model名作为表名（即自动由单数转为复数） freezeTableName: true, // 设置表名 tableName: 'my_very_custom_table_name', // 增加version字段，设为true或者想要的字段名 version: true // 不要createdAt createdAt: false, // 把updatedAt改成updateTimestamp updatedAt: 'updateTimestamp', // 同理 deletedAt: 'destroyTime', // engine，设置表引擎 engine: 'MYISAM' // 设置表注释 comment: "I'm a table comment!", // 索引选项，用来生成表时建立索引 indexes: [ // Create a unique index on email &#123; unique: true, fields: ['email'] &#125;, // Creates a gin index on data with the jsonb_path_ops operator &#123; fields: ['data'], using: 'gin', //PostgreSQL operator: 'jsonb_path_ops' &#125;, // By default index name will be [table]_[fields] // Creates a multi column partial index &#123; name: 'public_by_author', fields: ['author', 'status'], //聚合索引，带有条件 where: &#123; status: 'public' &#125; &#125;, // A BTREE index with a ordered field &#123; name: 'title_index', method: 'BTREE', // 建立一个btree索引 fields: ['author', &#123;attribute: 'title', collate: 'en_US', order: 'DESC', length: 5&#125;] &#125; ]&#125;)]]></content>
      <categories>
        <category>后端</category>
        <category>sequelizejs</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>后端</tag>
        <tag>sequelizejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelizejs的数据类型]]></title>
    <url>%2F2017%2F01%2F20%2Fsequelizejs%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[sequelize的文档混乱不堪，在这里整理一下，以后方便查阅。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Sequelize.STRING // VARCHAR(255)Sequelize.STRING(1234) // VARCHAR(1234)Sequelize.STRING.BINARY // VARCHAR BINARYSequelize.TEXT // TEXTSequelize.TEXT('tiny') // TINYTEXTSequelize.INTEGER // INTEGERSequelize.INTEGER.UNSIGNED // INTEGER UNSIGNEDSequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNEDSequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILLSequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILLSequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILLSequelize.BIGINT // BIGINTSequelize.BIGINT(11) // BIGINT(11)Sequelize.FLOAT // FLOATSequelize.FLOAT(11) // FLOAT(11)Sequelize.FLOAT(11, 12) // FLOAT(11,12)Sequelize.REAL // REAL PostgreSQL only.Sequelize.REAL(11) // REAL(11) PostgreSQL only.Sequelize.REAL(11, 12) // REAL(11,12) PostgreSQL only.Sequelize.DOUBLE // DOUBLESequelize.DOUBLE(11) // DOUBLE(11)Sequelize.DOUBLE(11, 12) // DOUBLE(11,12)Sequelize.DECIMAL // DECIMALSequelize.DECIMAL(10, 2) // DECIMAL(10,2)Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgresSequelize.DATE(6) // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precisionSequelize.DATEONLY // DATE without time.Sequelize.BOOLEAN // TINYINT(1)Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2'Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only.Sequelize.ARRAY(Sequelize.ENUM) // Defines an array of ENUM. PostgreSQL only.Sequelize.JSON // JSON column. PostgreSQL, SQLite and MySQL only.Sequelize.JSONB // JSONB column. PostgreSQL only.Sequelize.BLOB // BLOB (bytea for PostgreSQL)Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long)Sequelize.UUID // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically)Sequelize.RANGE(Sequelize.INTEGER) // Defines int4range range. PostgreSQL only.Sequelize.RANGE(Sequelize.BIGINT) // Defined int8range range. PostgreSQL only.Sequelize.RANGE(Sequelize.DATE) // Defines tstzrange range. PostgreSQL only.Sequelize.RANGE(Sequelize.DATEONLY) // Defines daterange range. PostgreSQL only.Sequelize.RANGE(Sequelize.DECIMAL) // Defines numrange range. PostgreSQL only.Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only.Sequelize.GEOMETRY // Spatial column. PostgreSQL (with PostGIS) or MySQL only.Sequelize.GEOMETRY('POINT') // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only.Sequelize.GEOMETRY('POINT', 4326) // Spatial column with geometry type and SRID. PostgreSQL (with PostGIS) or MySQL only.]]></content>
      <categories>
        <category>后端</category>
        <category>sequelizejs</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>后端</tag>
        <tag>sequelizejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataRedis简单使用]]></title>
    <url>%2F2016%2F11%2F23%2FSpringDataRedis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先启动一个redis容器，作为要使用的数据库1docker run --name redis-server -d -p 6379:6379 redis 新建一个maven项目，引入spring data redis1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-libs-release&lt;/id&gt; &lt;name&gt;Spring Releases&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 配置application.properties来连接redis1234spring.redis.host = 127.0.0.1spring.redis.database = 0spring.redis.port = 6379spring.redis.password = 写java代码，用来操作redis，用一个简单的lpop来演示：123456789101112131415161718192021222324package com.test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.data.redis.core.StringRedisTemplate;@SpringBootApplicationpublic class App &#123; private static final Logger LOGGER = LoggerFactory.getLogger(App.class); public static void main(String[] args) &#123; ApplicationContext ctx = SpringApplication.run(App.class, args); // 或者可以用@AutoWired StringRedisTemplate template = ctx.getBean(StringRedisTemplate.class); template.opsForList().leftPush("key", "value"); String data = template.opsForList().leftPop("key"); LOGGER.info("Get data : " + data); System.exit(0); &#125;&#125; 另外，可以配置Lettuce连接123456789@Configurationclass AppConfig &#123; @Bean public LettuceConnectionFactory redisConnectionFactory() &#123; return new LettuceConnectionFactory(new RedisStandaloneConfiguration("server", 6379)); &#125;&#125; 和Jedis连接12345678910@Configurationclass RedisConfiguration &#123; @Bean public JedisConnectionFactory redisConnectionFactory() &#123; RedisStandaloneConfiguration config = new RedisStandaloneConfiguration("server", 6379); return new JedisConnectionFactory(config); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>spring</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中的弱引用]]></title>
    <url>%2F2016%2F09%2F02%2FJAVA%E4%B8%AD%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ES6中WeakMap，WeakSet，可以自主检测集合中的key-value pair有没有引用者，并及时做出清除，也就是被垃圾回收器回收。JAVA中的弱引用也是和垃圾回收器密切相关的。 JAVA中的引用分为以下几个类型： 强引用：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收 软引用：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些 弱引用：如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存，利用jdk中的ThreadLocal就是弱引用的，具体间下面的详细说明。 虚引用：如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收，虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列联合使用，虚引用主要用来跟踪对象 被垃圾回收的活动。 它们由强到弱依次是：强引用、软引用、弱引用、虚引用。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之CyclicBarrier]]></title>
    <url>%2F2016%2F08%2F10%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCyclicBarrier%2F</url>
    <content type="text"><![CDATA[CyclicBarrier可以用于多线程计算数据,最后合并计算结果的场景。123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Shit implements Runnable &#123; private static ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;String, Integer&gt;(); private static CyclicBarrier barrier; public static void main(String[] args) throws Exception &#123; barrier = new CyclicBarrier(5, new Runnable() &#123; // 栅栏动作，在计数器为0的时候执行 @Override public void run() &#123; System.out.println("所有得分得到！"); int result = 0; for (String key : map.keySet()) &#123; result += map.get(key); &#125; System.out.println("平均值为：" + (result/5)); &#125; &#125;); ExecutorService es = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; es.execute(new Shit()); &#125; &#125; @Override public void run() &#123; try &#123; int score = new Random().nextInt(100); map.put("科目" + Thread.currentThread().getName() , score); System.out.println("科目" + Thread.currentThread().getName() + "已获得得分: " + score); Thread.sleep(1000); barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 只有当五个线程都结束时，才会进入计算平均值的方法中，CyclicBarrier起到了一个栅栏作用，一旦线程都达到了栅栏处，就会进入闸门方法中。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之线程池]]></title>
    <url>%2F2016%2F08%2F09%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[Executor框架提供了各种类型的线程池，主要有以下几个： newFixedThreadPool()：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 newSingleThreadExecutor()：该方法返回一个只有一个线程的线程池。当有一个新的任务提交时，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 newCachedThreadPool()：该方法返回一个根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但如果有空闲线程可以复用，则会优先使用可以复用的线程。如果所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。 newSingleThreadScheduledExecutor()：该方法返回一个scheduledExecutorService对象，线程池大小为1。ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间内执行某人物的功能，如在某个固定的延时之后执行(schedule)，或者周期性(scheduleAtFixedRate, scheduleAtFixedDelay)的执行某个任务。 newScheduledThreadPool()：该方法也返回一个ScheduledExecutorService对象，但是可以指定线程的数量。 ThreadPoolExcutor()： corePollSize: 池中所保存的线程数，包括空闲线程，也就是核心池的大小 maximumPoolSize：池中允许的最大线程数 keepAliveTime：当线程数量大于corePoolSize值时，在没有超过指定的时间内是不从线程池中将空闲线程删除的，如果超过此时间，则删除。 unit: keepAliveTime参数的时间单位 WorkQueue：执行前用于保持任务的队列。此队列仅保持由execute方法提交的Runnable任务。 为了更好地理解以上使用的关系，可以进行以下详细化的注释： A 代表欲执行的runnable的数量 B 代表corePoolSize C 代表maximumPoolSize D 代表A-B E 代表 new LinkedBlockingDeque&lt;Runnable&gt;；队列，无构造参数 F 代表SynchronousQueue队列 G 代表KeepAliveTime 有几个操作结论： 如果A&lt;=B，那么马上创建线程运行这个任务，并不放入扩展队列中，其他参数功能忽略。 如果A&gt;B&amp;&amp;A&lt;=C&amp;&amp;E，则C和G参数忽略，并把D放入E中等待执行。 如果A&gt;B&amp;&amp;&amp;A&lt;=C&amp;&amp;F，则C和G参数有效，马上创建线程运行这些任务，不把D放在F中，D执行完任务后在指定时间后发生超时则将D进行清除。 如果A&gt;B&amp;&amp;A&gt;C&amp;&amp;E，则C和G参数忽略，并把D放入E中等待执行。 如果A&gt;B&amp;&amp;A&gt;C&amp;&amp;E，则处理C的任务，其他任务则不再处理抛出异常。Executor接口地invokeAny和invokeAll方法使用invokeAny()方法，当任意一个线程找到结果之后，立刻终结中断所有线程。执行结果可能会有以下三种情况： 任务都执行成功，使用过第一个任务返回的结果。 任务都失败了，抛出Exception，invokeAny方法将抛出ExecutionException。 部分任务失败了，会使用第一个成功的任务返回的结果。 使用invokeAll()方法，要么全成功，要么部分失败，中断退出。运行结果可能出现的情况： 全部运行成功 部分运行失败，剩余任务被取消]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之Future与CompletionSerivce]]></title>
    <url>%2F2016%2F08%2F09%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BFuture%E4%B8%8ECompletionSerivce%2F</url>
    <content type="text"><![CDATA[Future调用get()方法时，是阻塞的，也就是如果调用Future对象的get()方法时，任务尚未完成，则调用get()方法时会一直阻塞到此任务完成为止。如果是这样的结果，则前面先执行的任务一旦耗时很多，则后面调用get()方法就成为了阻塞状态，排队进行等待，大大影响运行效率。主线程不能保证首先获得的是最先完成任务的返回值，这就是Future的缺点。下面用一个例子来演示Future批处理的缺点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Shit implements Callable&lt;String&gt; &#123; private String username; private long sleepValue; Shit(String username, long sleepValue) &#123; this.username = username; this.sleepValue = sleepValue; &#125; @Override public String call() throws Exception &#123; System.out.println(username); Thread.sleep(sleepValue); return "Result : " + username; &#125; @SuppressWarnings(&#123; "unchecked", "rawtypes" &#125;) public static void main(String args[]) &#123; List&lt;Callable&gt; callableList = new ArrayList&lt;Callable&gt;( Arrays.asList(new Shit("username1", 5000), new Shit("username2", 4000), new Shit("username3", 3000), new Shit("username4", 2000), new Shit("username5", 1000))); List&lt;Future&gt; futureList = new ArrayList&lt;Future&gt;(); ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingDeque()); for (int i = 0; i &lt; 5; i++) &#123; futureList.add(executor.submit(callableList.get(i))); &#125; try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(futureList.get(i).get() + " : " + System.currentTimeMillis()); &#125; &#125; catch (InterruptedException | ExecutionException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;/* 输出：username1username5username4username3username2由于第一个任务耗时较长，因此后面任务的get()被阻塞。Result : username1 : 1520214428110Result : username2 : 1520214428110Result : username3 : 1520214428110Result : username4 : 1520214428110Result : username5 : 1520214428110*/ CompletionSerivce可以解决这个批处理等待问题。也就是哪个任务先执行完，CompletionSerivce就先取得这个任务的返回值再处理。 1234567891011121314151617181920212223242526272829303132333435public static void main(String args[]) &#123; List&lt;Callable&gt; callableList = new ArrayList&lt;Callable&gt;( Arrays.asList(new Shit("username1", 5000), new Shit("username2", 4000), new Shit("username3", 3000), new Shit("username4", 2000), new Shit("username5", 1000))); ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingDeque()); CompletionService cs = new ExecutorCompletionService(executor); for (int i = 0; i &lt; 5; i++) &#123; cs.submit(callableList.get(i)); &#125; try &#123; for (int i = 0; i &lt; 5; i++) &#123; // take可以阻塞式地获得下一个任务的future // poll方式则是非阻塞式地获得下一个任务的future System.out.println(cs.take().get() + " : " + System.currentTimeMillis()); &#125; &#125; catch (InterruptedException | ExecutionException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;/* 输出username2username5username4username3username1Result : username5 : 1520215083204Result : username4 : 1520215084203Result : username3 : 1520215085203Result : username2 : 1520215086203Result : username1 : 1520215087203*/]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之ThreadLocal]]></title>
    <url>%2F2016%2F08%2F05%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal%2F</url>
    <content type="text"><![CDATA[当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度看，目标变量就像是线程的本地变量。下面是ThreadLocal的set方法源码，可以看出，set由以下几个步骤组成： 首先获取当前线程 从当前线程获取一个ThreadLocalMap的对象 如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值所以，ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。这就实现了“目标变量就像是线程的本地变量”这一特性。12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocal的内存泄漏： ThreadLocalMap里面的key为ThreadLocal对象的弱引用，当一个线程调用ThreadLocal的set方法设置变量时候，当前线程的ThreadLocalMap里面就会存放一个记录，这个记录的key为ThreadLocal的引用，value则为设置的值。如果当前线程一直存在而没有调用ThreadLocal的remove方法，并且这时候其它地方还是有对ThreadLocal的引用，则当前线程的ThreadLocalMap变量里面会存在ThreadLocal变量的引用和value对象的引用是不会被释放的，这就会造成内存泄露的。但是考虑如果这个ThreadLocal变量没有了其他强依赖，而当前线程还存在的情况下，由于线程的ThreadLocalMap里面的key是弱依赖，则当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用会被在gc的时候回收，但是对应value还是会造成内存泄露，这时候ThreadLocalMap里面就会存在key为null但是value不为null的entry项。 用法实例：123456789101112131415161718192021222324252627282930313233343536public class Shit&#123; private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() &#123; public Integer initialValue() &#123; return 0; &#125; &#125;; public static void main(String [] args) &#123; TestClient t1 = new TestClient(); TestClient t2 = new TestClient(); TestClient t3 = new TestClient(); t1.start(); t2.start(); t3.start(); &#125; private static class TestClient extends Thread&#123; public void run() &#123; for(int i =0;i&lt;3;i++) &#123; seqNum.set(i); System.out.println(Thread.currentThread().getName() + ": seqNum = " + seqNum.get()); &#125; &#125; &#125;&#125;/* 输出：Thread-0: seqNum = 0Thread-1: seqNum = 0Thread-2: seqNum = 0Thread-1: seqNum = 1Thread-0: seqNum = 1Thread-0: seqNum = 2Thread-1: seqNum = 2Thread-2: seqNum = 1Thread-2: seqNum = 2*/]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之ReetrantLock]]></title>
    <url>%2F2016%2F08%2F03%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantLock%2F</url>
    <content type="text"><![CDATA[ReentrantLock类似于synchronized，有着相同的语义，可以实现重入锁的特性。但是相对于synchronized，ReentrantLock具有以下几个特性： ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。 ReenTrantLock提供了一个Condition（条件）类，用来实现唤醒需要唤醒的线程们。 ReenTrantLock可以通过通过lock.lockInterruptibly()来实现锁中断机制。 ReenTrantLockd的等待可中断，持有锁的线程不释放的时候，正在等待的线程可以放弃等待，通过tryLock来实现。 synchronized在jvm层面实现，而ReenTrantLock通过代码实现，需要手动释放锁。 竞争激烈的情况下，synchronized的性能要弱于ReenTrantLock。 一个普通使用例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class Shit implements Runnable &#123; final static ReentrantLock lock = new ReentrantLock(); final static Condition condition=lock.newCondition(); static int count = 0; public static void main(String[] args) throws InterruptedException &#123; Shit shit = new Shit(); Thread t1 = new Thread(shit, "T1"); t1.start(); Thread.sleep(200); // 不等待会报错 signal(); &#125; @Override public void run() &#123; try &#123; if(lock.tryLock()) &#123; condition.await(); for(int i=0; i&lt;5;i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + (count++)); &#125; &#125;else &#123; System.out.println("Lock failed!"); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void signal() &#123; try &#123; if(lock.tryLock()) &#123; condition.signal(); // 必须先lock再signal &#125;else &#123; System.out.println("Lock failed!"); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 公平锁与非公平锁123456789101112131415161718192021222324252627282930313233public class Shit implements Runnable &#123; final static ReentrantLock lock = new ReentrantLock(true); public static void main(String[] args) throws InterruptedException &#123; Shit shit = new Shit(); Thread t1 = new Thread(shit, "T1"); Thread t2 = new Thread(shit, "T2"); t1.start(); t2.start(); &#125; @Override public void run() &#123; while (true) &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + ": get the lock"); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;/* 输出T1: get the lockT2: get the lockT1: get the lockT2: get the lock......*/ 公平锁的前提下，两个线程会交替获得锁，当ReentrantLock没有设为true时，则是非公平锁，不会出现这种现象。同样地，synchronized也不会出现公平锁的交替获得锁的现象，而是随机的。12345678910111213@Overridepublic void run() &#123; while (true) &#123; synchronized(this) &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + ": get the lock"); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 可中断锁12345678910111213141516171819202122232425262728293031import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Shit &#123; public static void test3() throws Exception &#123; final Lock lock = new ReentrantLock(); lock.lock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; lock.lock(); // lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(Thread.currentThread().getName() + " interrupted."); &#125; &#125; &#125;); t1.setName("T1"); t1.start(); Thread.sleep(1000); t1.interrupt(); &#125; public static void main(String[] args) throws Exception &#123; test3(); &#125;&#125; 即使调用了interrupt，子线程仍然阻塞于获取锁。使用lockInterruptibly后，则会优先响应interrupt请求。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之CountDownLatch]]></title>
    <url>%2F2016%2F08%2F03%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCountDownLatch%2F</url>
    <content type="text"><![CDATA[对于倒计时器锁，一种典型的应用就是火箭发射。火箭发射前，要等待所有的检测线程完工。CountDownLatch接受一个整数作为参数，即当前计数器的计数个数。 下面的这个例子演示了一个模拟的火箭发射过程：12345678910111213141516171819202122232425262728293031323334package fuck;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Shit implements Runnable&#123; private static CountDownLatch cdLatch = new CountDownLatch(10); private int value; public static void main(String[] args) throws Exception &#123; final Shit shit = new Shit(); ExecutorService exec = Executors.newFixedThreadPool(10); for(int i=0;i&lt;10;i++) &#123; exec.submit(shit); &#125; cdLatch.await(); System.out.println("Fire!"); exec.shutdown(); &#125; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(10)*1000); System.out.println("Check Over !"); cdLatch.countDown(); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用cdLatch.await()后，该线程将会等待子线程countdown完毕后才能执行。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之ReentrantReadWriteLock]]></title>
    <url>%2F2016%2F08%2F03%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantReadWriteLock%2F</url>
    <content type="text"><![CDATA[读写分离锁可以有效地帮助减少竞争，由于读操作并不对数据完整性造成破坏，因此，读写锁允许多个线程同时进行读操作，使得多个线程间真正并行。但是读写操作间仍然是需要相互等待和持有锁的，这些关系可以用下图来表示： 读 写 读 非阻塞 阻塞 写 阻塞 阻塞 下面用一个例子来对比ReentrantReadWriteLock和ReentrantLock。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package fuck;import java.util.Random;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class Shit&#123; private static Lock lock = new ReentrantLock(); private static ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); private static Lock rLock = rwLock.readLock(); private static Lock wLock = rwLock.writeLock(); private int value; public Object handleRead(Lock lock) throws InterruptedException&#123; try &#123; lock.lock(); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + ": read value" + value); return value; &#125;finally &#123; lock.unlock(); &#125; &#125; public void handleWrite(Lock lock, int index) throws InterruptedException&#123; try &#123; lock.lock(); Thread.sleep(1000); value = index; System.out.println(Thread.currentThread().getName() + ": write value" + value); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) throws Exception &#123; final Shit shit = new Shit(); Runnable readRun = new Runnable() &#123; @Override public void run() &#123; try &#123; //shit.handleRead(rLock); shit.handleRead(lock); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Runnable writeRun = new Runnable() &#123; @Override public void run() &#123; try &#123; //shit.handleWrite(rLock, new Random().nextInt()); shit.handleWrite(lock, new Random().nextInt()); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for(int i =0 ; i&lt;18;i++) &#123; new Thread(readRun, "T"+i).start(); &#125; for(int i = 18; i&lt;20;i++) &#123; new Thread(writeRun, "T" + i).start(); &#125; &#125;&#125; 当锁类型为读写锁时，因为读取过程不阻塞，所有线程将同时开始读取数据，同时，写线程在一秒后也开始写，两个写过程互斥，总共用时2秒。当锁类型为重入锁时，所有线程任意过程都互相阻塞，因此用时大于20秒。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之semaphore]]></title>
    <url>%2F2016%2F08%2F02%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsemaphore%2F</url>
    <content type="text"><![CDATA[信号量是对锁的扩展，无论是synchronized还是ReetrantLock，一次都只允许一个线程访问一个资源，而信号量却可以指定多个线程，同时访问一个资源。 123456789101112131415161718192021222324252627import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class Shit implements Runnable &#123; final Semaphore semp = new Semaphore(5); public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newFixedThreadPool(20); final Shit shit = new Shit(); for (int i = 0; i &lt; 20; i++) &#123; exec.submit(shit); &#125; &#125; @Override public void run() &#123; try &#123; semp.acquire(); Thread.sleep(2000); System.out.println(Thread.currentThread().getId() + ":done"); semp.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面这个例子中，将会输出以5个线程为一组的提示文本。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发编程之Synchronized]]></title>
    <url>%2F2016%2F08%2F01%2FJAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized%2F</url>
    <content type="text"><![CDATA[JAVA中的Synchronized可以用来修饰以下几个对象： 代码块，作用范围是用大括号括起来的部分。 方法，作用范围是整个方法。 静态方法，作用范围是整个静态方法。 类，作用范围是Synchronized后面括号括起来的部分。 Synchronized作用于代码块12345678910111213141516171819202122232425262728293031public class Shit implements Runnable &#123; static int count = 0; public static void main(String[] args) throws InterruptedException &#123; Shit shit = new Shit(); Thread t1 = new Thread(shit, "T1"); Thread t2 = new Thread(shit, "T2"); t1.start(); t2.start(); &#125; @Override public void run() &#123; synchronized(this) &#123; for(int i=0; i&lt;5;i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + (count++)); &#125; &#125; &#125;&#125;/* T1:0T1:1T1:2T1:3T1:4T2:5T2:6T2:7T2:8T2:9*/ 当两个并发线程访问同一个synchronized代码块时，同一个时刻只能有一个线程得到执行，而另一个线程会被阻塞，直至这个线程执行完成。除了this外，也可以指定对象进行加锁，没有明确对象时，可以使用byte[0]来充当锁的对象。 Synchronized作用于方法12345678910@Overridepublic void run() &#123; countNumber();&#125; private synchronized void countNumber()&#123; for(int i=0; i&lt;5;i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + (count++)); &#125;&#125; Synchronized修饰一个方法，就是在方法的前面加synchronized。和修饰一个代码块类似，只是作用范围不一样。前者是大括号内的代码，后者是整个方法。 Synchronized作用于静态方法1234567891011121314151617@Overridepublic void run() &#123; countNumber();&#125; private static synchronized void countNumber()&#123; for(int i=0; i&lt;5;i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + (count++)); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Shit(), "T1"); Thread t2 = new Thread(new Shit(), "T2"); t1.start(); t2.start();&#125; 静态方法属于类，两个线程相当于使用了同一把锁，因此可以线程同步。 Synchronized作用于类123456789@Overridepublic void run() &#123; synchronized(Shit.class) &#123; for(int i=0; i&lt;5;i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + (count++)); &#125; &#125;&#125; 同上一个一致，都是对类加锁，两个线程相当于使用了同一把锁，因此可以线程同步。]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真正理解nodejs中的EventLoop]]></title>
    <url>%2F2016%2F06%2F01%2F%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3nodejs%E4%B8%AD%E7%9A%84EventLoop%2F</url>
    <content type="text"><![CDATA[nodejs是基于的事件的平台。这意味着node中发生的一切都是对事件的反应。事务通过node遍历一个级联的回调。在node.js里，任何异步方法（除timer,close,setImmediate之外）完成时，都会将其callback加到poll queue里,并立即执行。 远离开发层面，这些功能都是由一个叫做libuv的库提供的。 Eventloop可能是nodejs中最被人所误解的一个概念。 一般的错误认识错误认识: eventloop运行于一个单独的相对独立于用户代码的线程中 错误：eventloop运行于一个相对独立于用户代码的线程中。有一个专门运行eventloop的线程，同时有一个运行用户代码的主线程。每当有异步操作时，主线程将工作交给事件循环线程，一旦完成，事件循环线程将ping主线程执行回调。 正确：只有一个线程执行JavaScript代码，这是事件循环运行的线程。回调函数的执行（Node.js中每个用户的代码都是一个回调）是由事件循环做。稍后会更深入地讨论这个问题。 错误认识：异步操作由一个线程池处理 错误：异步操作，如IO工作，HTTP请求或与数据库总是由libuv线程池来装载。 正确：libuv默认情况下创建一个有四个线程的线程池线来加载异步工作。今天的操作系统已经为许多I/O任务提供异步接口。只要有可能，libuv将使用这些异步接口，避免线程池的使用。这同样适用于像数据库这样的第三方子系统。驱动程序的作者宁愿使用异步接口，也不愿意使用线程池。简言之：只有在没有其他方法的情况下，线程池才会被用于异步I/O。 错误认识：eventloop就像栈或队列 错误：事件循环按FIFO不断地遍历异步任务，并在任务完成时执行回调。 虽然有类似队列的结构，但事件循环并没有完全类似于栈。事件循环作为一个过程，是一组由特定任务组成的按循环方式处理的过程。 理解事件循环处理过程要真正理解事件循环，我们必须了解哪些工作是在哪个阶段完成的。下图展示了这一过程： 这一过程由以下几个部分组成： 计时器任何由setTimeout()或setInerval()定时的操作都会在这里执行。 IO回调这里大部分的回调函数将被处理。所有的用户代码在Node.js基本上是在回调（例如一个回调函数传入的HTTP请求会触发一个级联的回调），这是用户的代码。 IO轮询对下一次运行将要处理的新事件的轮询。有两个主要方法： 执行下限时间已经达到的timers的回调 处理poll队列中的事件 当事件循环进入poll阶段，并且没有timers被设定时，将发生两种情况之一： 如果poll队列不空，事件循环将遍历其回调执行同步直到队列中的回调都被调用，或者达到系统上限。 如果poll队列是空的，那么两个事件中的一个将会发生： 如果脚本被setImmdiate()定时器定时，eventloop将会结束poll阶段，并进入下一个阶段 如果代码不被setimmediate()定时器定时，事件循环会等待回调被添加到队列中，然后立刻执行它们。 如果poll队列为空，eventloop将会检查哪些timers的已经到期。如果有一个或多个timer到期，eventloop将会回到timers阶段去执行回调。 Set Immediate运行所有由setImmediate()发起的操作。 Close这里是所有的(close)事件回调的处理。 例如有以下代码：12345678910111213141516171819202122const fs = require('fs');function someAsyncOperation(callback) &#123; // 假设需要95ms fs.readFile('/path/to/file', callback);&#125;const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100);someAsyncOperation(() =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 10) &#123; // do nothing &#125;&#125;); console最终的输出为105毫秒，它的过程是这样的： 当eventloop来到poll阶段时，它的队列为空，因为此时readFile还没有结束。所以它将等待最新的timer到期。 95ms后，readFile结束，callback执行还需要另外的10ms。 callback执行结束，因为队列中已经没有了其他的callback,它将回到timers阶段，setTimeOut()执行callback，得到105ms。]]></content>
      <categories>
        <category>前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>nodejs</tag>
        <tag>eventloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 利用ng-zorro实现全局http错误拦截与提示]]></title>
    <url>%2F2016%2F05%2F23%2FAngular%20%E5%88%A9%E7%94%A8NG-ZORRO%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80http%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA%E4%B8%8E%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[拦截http错误http全局错误的拦截可以采用先扩展Http类，重写请求方法后发出错误，之后实现ErrorHandler类来实现。下面是部分关键代码：123456789101112131415161718192021222324252627282930313233343536export class InterceptedHttp extends Http &#123; constructor( backend: ConnectionBackend, defaultOptions: RequestOptions) &#123; super(backend, defaultOptions); &#125; request(url: string | Request, options?: RequestOptionsArgs): Observable&lt;Response&gt; &#123; // 在此处可以写一些拦截请求的操作 this.updateUrl(url); return super.request(url, options); &#125; get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; &#123; return super.get(url, this.getRequestOptionArgs(options)); &#125; .... // 改写请求url,加上req private updateUrl(req: string) &#123; return "/api/" + req; &#125; // 改写请求头部 private getRequestOptionArgs(options?: RequestOptionsArgs) : RequestOptionsArgs &#123; if (options == null) &#123; options = new RequestOptions(); &#125; if (options.headers == null) &#123; options.headers = new Headers(); &#125; options.headers.append('Content-Type', 'application/json'); return options; &#125;&#125; 以上是一个简单的http请求拦截器，它可以改写请求参数，改写请求头部，还有一种写法是实现HttpInterceptor接口（angular5新添加)。1234567891011121314151617181920212223export class MyHttpInterceptor implements HttpInterceptor &#123;constructor() &#123; &#125;intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123;console.log("intercepted request ... ");// Clone the request to add the new header.const authReq = req.clone(&#123; headers: req.headers.set("headerName", "headerValue")&#125;);console.log("Sending request with new header now ...");//send the newly created requestreturn next.handle(authReq).catch((error, caught) =&gt; &#123; //intercept the respons error and displace it to the console console.log("Error Occurred"); console.log(error); //return the error to the method that called it return Observable.throw(error);&#125;) as any;&#125;&#125; 接下来实现ErrorHandler类，它可以捕捉各种类型的错误，包括Http请求错误。12345678910111213141516171819202122232425262728export class CustomErrorHandler implements ErrorHandler &#123; constructor( @Inject(NotificationService) private notificationService: NotificationService) &#123; &#125; handleError(error: any): void &#123; let msg = this.httpErrorHandler(error.rejection || error); &#125; httpErrorHandler(err): string &#123; let message = ''; if (err.status) &#123; switch (err.status) &#123; case 502: case 500: message = `服务器故障 : \n详细信息 : $&#123;err.statusText&#125;:$&#123;err.json().message&#125;`; break; case 401: message = `$&#123;err.json().message&#125;` break; default: break; &#125; &#125; else &#123; message = err.message; &#125; return message; &#125; 发送错误消息捕捉到错误信息以后，需要通知某个服务来显示消息，利用nzMessageService将其显示出来，nzMessageService显示时需要视图载体，这里采用AppComponent作为载体。 为ErrorHandler添加错误通知功能1234handleError(error: any): void &#123; let msg = this.httpErrorHandler(error.rejection || error); this.notificationService.error(msg);&#125; notificationService必须类似于EventEmitter一样，收到消息后自动发射到接受方，所以可以采用Subject来作为Message的主体，让Message可以被订阅，也可以被按需求发射。 Message的模型如下: 12345678910111213141516171819export class Message&#123; type: string; message: string; constructor(type, message)&#123; this.type = type; this.message = message; &#125;&#125;export class NotificationService &#123; public message: Subject&lt;Message&gt; = new Subject&lt;Message&gt;(); constructor() &#123; &#125; error(message: string): void &#123; this.message.next(new Message('error', message)); &#125;&#125; 之后，只要在AppComponent中订阅Message，就可以在前台进行提示了！123456789101112export class AppComponent implements OnInit &#123; title = 'app'; constructor(private notification: NotificationService, private nzMessageService: NzMessageService) &#123; &#125; ngOnInit()&#123; this.notification.message.distinctUntilChanged().subscribe((msg)=&gt;&#123; this.nzMessageService.create(msg.type, msg.message); &#125;); &#125;&#125; 最后，注册以上这几个服务到AppModule中。123456789101112131415export function httpFactory(xhrBackend: XHRBackend, requestOptions: RequestOptions): Http &#123; return new InterceptedHttp(xhrBackend, requestOptions);&#125;providers: [ &#123; provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] &#125;, NotificationService, // added &#123; provide: ErrorHandler, useClass: CustomErrorHandler &#125;, NzMessageService, &#123; provide: NZ_MESSAGE_CONFIG, useValue: &#123; nzDuration: 7000 &#125; &#125; ],]]></content>
      <categories>
        <category>前端</category>
        <category>angular</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angular</tag>
        <tag>ng-zorro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular5 jwt验证]]></title>
    <url>%2F2016%2F05%2F21%2FAngular5%20JWT%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[首先写一个简单的bootstrap的登陆表单。新建loginComponent，然后在hmtl里写:12345678910111213141516171819&lt;div class="col-md-6 col-md-offset-3"&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;form name="form" (ngSubmit)="f.form.valid &amp;&amp; login()" #f="ngForm" novalidate&gt; &lt;div class="form-group" [ngClass]="&#123; 'has-error': f.submitted &amp;&amp; !username.valid &#125;"&gt; &lt;label for="username"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" name="username" [(ngModel)]="user.username" #username="ngModel" required /&gt; &lt;div *ngIf="f.submitted &amp;&amp; !username.valid" class="help-block"&gt;Username is required&lt;/div&gt; &lt;/div&gt; &lt;div class="form-group" [ngClass]="&#123; 'has-error': f.submitted &amp;&amp; !password.valid &#125;"&gt; &lt;label for="password"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" name="password" [(ngModel)]="user.password" #password="ngModel" required /&gt; &lt;div *ngIf="f.submitted &amp;&amp; !password.valid" class="help-block"&gt;Password is required&lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;button [disabled]="loading" class="btn btn-primary"&gt;Login&lt;/button&gt; &lt;i class="fa fa-spinner fa-spin" *ngIf="loading"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 在loginComponent内写：1234567891011121314151617181920212223242526272829export class LoginComponent implements OnInit &#123; user: User = new User(); loading = false; error = ''; constructor( private router: Router, private authenticationService: AuthenticationService) &#123; &#125; ngOnInit() &#123; // reset login status this.authenticationService.logout(); &#125; login() &#123; this.loading = true; this.authenticationService.login(this.user) .subscribe(result =&gt; &#123; if (result === true) &#123; this.router.navigate(['/']); &#125; else &#123; this.error = 'Username or password is incorrect'; this.loading = false; &#125; &#125;,error=&gt;&#123; this.loading = false; &#125;); &#125;&#125; UserModel的代码：12345export class User&#123; id: number; username: string; password: string;&#125; login后，要根据用户名密码来在后台签名，签名结果token返回前台，前台接收到token后，存储到localstorage中，然后以后每次请求时，都要带上token作为头部。12345678910111213141516171819202122232425const User = require('../models/user.model');const jwt = require('jsonwebtoken');const secret = require('../secret');async function login(ctx) &#123; const &#123; query &#125; = ctx.request let user = await User.find(&#123;where: &#123;id: query.id&#125;&#125;); if (query.password === user.password) &#123; ctx.status = 200 ctx.body = &#123; message: '登录成功', user: user, token: jwt.sign(&#123; data: user, exp: Math.floor(Date.now() / 1000) + (60 * 60), // 60 seconds * 60 minutes = 1 hour &#125;, secret), &#125; &#125; else &#123; let err = new Error('Password Error'); err.status = 401; err.message = `密码错误`; throw err; &#125;&#125;module.exports = &#123; login &#125;; koa-jwt添加进来以后，引入公钥，然后排除login api：1jwt(&#123; secret: secret &#125;).unless(&#123; path: [/^\/api\/login/] &#125;) 这样，当前台发出请求时，就会得到签名过的token，为了统一处理，写一个共通处理的httpinterceptor，这里面用到了ngx-notify。1234567891011121314151617181920212223242526272829303132333435363738394041export class DefaultHttpInterceptor implements HttpInterceptor &#123; constructor(private auth: AuthenticationService, private notifyService: NotifyService) &#123; &#125; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpSentEvent | HttpHeaderResponse | HttpProgressEvent | HttpResponse&lt;any&gt; | HttpUserEvent&lt;any&gt;&gt; &#123; let url = req.url; if (!url.startsWith('https://') &amp;&amp; !url.startsWith('http://')) &#123; url = environment.api + url; &#125; let options = &#123; url: url &#125;; if (!url.includes('login')) &#123; options['setHeaders'] = &#123; Authorization: `Bearer $&#123;this.auth.getToken()&#125;` &#125; &#125; const newReq = req.clone(options); const started = Date.now(); return next.handle(newReq).pipe( tap(event =&gt; &#123; if (event instanceof HttpResponse) &#123; const elapsed = Date.now() - started; console.log(`Request for $&#123;req.urlWithParams&#125; took $&#123;elapsed&#125; ms.`); &#125; &#125;, error =&gt; &#123; switch (error.status) &#123; case 401: // 权限处理 this.notifyService.error('401', `错误代码为：$&#123;error.message&#125;`); break; case 404: this.notifyService.error('404', `API不存在`); break; case 500: this.notifyService.error('500', error.message); break; &#125; &#125;)); &#125;&#125; 过程中遇到的坑： httpinterceptor只支持httpClient而不支持http。 koa-jwt只支持自动校验，不支持sign。]]></content>
      <categories>
        <category>全栈</category>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>全栈</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular5 表单]]></title>
    <url>%2F2016%2F05%2F21%2FAngular5%20%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[模板式验证我们把HTML表单控件（比如&lt;input&gt;和&lt;select&gt;）放进组件模板中，并用ngModel等指令把它们绑定到组件中数据模型的属性上。 不用自己创建Angular表单控件对象。Angular指令会使用数据绑定中的信息创建它们。 我们不用自己推送和拉取数据。Angular使用ngModel来替你管理它们。 当用户做出修改时，Angular会据此更新可变的数据模型。利用双向绑定，模板引用值，当name为invalid时，表单提示将会出现。对于数据的控制都放在模板内，可用的属性可能包括：required,minLength等。123456789101112131415161718192021&#123;&#123;diagnostic&#125;&#125;&lt;div class="form-group"&gt; &lt;label for="name"&gt;Name&lt;/label&gt;&lt;input type="text" class="form-control" required [(ngModel)]="model.name" name="name" #name="ngModel"&gt;&lt;div [hidden]="name.valid || name.pristine" class="alert alert-danger"&gt; Name is required&lt;/div&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt; &lt;input type="text" class="form-control" [(ngModel)]="model.alterEgo" miniLength="3" name="alterEgo" #alterEgo&gt;&lt;/div&gt;&lt;div *ngIf="alterEgo.errors?.miniLength" class="alert alert-danger"&gt;Should be at least 3 characters&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="power"&gt;Hero Power&lt;/label&gt; &lt;select class="form-control required" [(ngModel)]="model.power" name="power"&gt; &lt;option *ngFor="let pow of powers" [value]="pow"&gt;&#123;&#123;pow&#125;&#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 响应式验证把对表单的控制都放在组件一侧，统一控制，不在模板内进行处理。12345678910111213141516171819202122232425constructor(private fb: FormBuilder) &#123;&#125;ngOnInit(): void &#123; this.heroForm = this.fb.FormGroup(&#123; 'name': new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i) ]), 'alterEgo': new FormControl(this.hero.alterEgo), 'power': new FormControl(this.hero.power, Validators.required) &#125;);&#125;get name() &#123; return this.heroForm.get('name'); &#125;get power() &#123; return this.heroForm.get('power'); &#125;export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn &#123; return (control: AbstractControl): &#123;[key: string]: any&#125; =&gt; &#123; const forbidden = nameRe.test(control.value); return forbidden ? &#123;'forbiddenName': &#123;value: control.value&#125;&#125; : null; &#125;;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>angular</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular5 自定义管道与指令]]></title>
    <url>%2F2016%2F05%2F21%2FAngular5%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E9%81%93%E4%B8%8E%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Angular有很多内置指令与管道，但有时候还是要添加自定义的管道或指令。 自定义指令可以通过ng g d选项来创建一个新的指令。例如可以定义一个highlight指令，并可以在其中应用@HostListener,@HostBingding,@Input等装饰器。123456789101112131415161718192021222324@Directive(&#123; selector: '[highlight]'&#125;)export class HighlightDirective &#123; constructor(private elem: ElementRef, private renderer: Renderer) &#123; &#125; private color :string; @Input('highlight') highlightColor: string; @HostListener('mouseenter') onMouseEnter() &#123; console.log(this.highlightColor); this.renderer.setElementStyle(this.elem.nativeElement, 'backgroundColor', this.highlightColor); &#125; @HostListener('mouseleave') onMouseLeave() &#123; this.renderer.setElementStyle(this.elem.nativeElement, 'backgroundColor', null); &#125; @HostBinding('attr.role') role = 'button';&#125; 自定义管道可以使用ng g p来创建一个新的自定义管道。例如，可以创建一个判断是否为0的管道。12345678910111213@Pipe(&#123; name: 'isZeroPipe'&#125;)export class IsZeroPipe implements PipeTransform &#123; transform(value: any, args?: any): any &#123; if(value)&#123; return 'NotZero'; &#125;else&#123; return 'Zero'; &#125; &#125;&#125; 内置管道 管道 类型 功能 DatePipe 纯管道 日期管道，格式化日期 JsonPipe 非纯管道 将输入数据对象经过JSON.stringify()方法转换后输出对象的字符串 UpperCasePipe 纯管道 将文本所有小写字母转换成大写字母 LowerCasePipe 纯管道 将文本所有大写字母转换成小写字母 DecimalPipe 纯管道 将数值按特定的格式显示文本 CurrentcyPipe 纯管道 将数值转百分比格式 SlicePipe 非纯管道 将数组或者字符串裁剪成新子集]]></content>
      <categories>
        <category>前端</category>
        <category>angular</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng-alain源码简析]]></title>
    <url>%2F2016%2F05%2F20%2Fng-alain%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[外围配置Dockerfile12345678910111213141516171819202122232425262728293031323334# STEP 1: Build// copy package.json和lock到当前工作目录// node执行install,把创建好的./node_modules复制到新创建的ng-alain文件夹下// 设置工作目录为/ng-alain// 拷贝所有源文件到工作目录中FROM node:8-alpine as builderLABEL authors=&quot;cipchk &lt;cipchk@qq.com&gt;&quot;COPY package.json package-lock.json ./RUN npm set progress=false &amp;&amp; npm config set depth 0 &amp;&amp; npm cache clean --forceRUN npm i &amp;&amp; mkdir /ng-alain &amp;&amp; cp -R ./node_modules ./ng-alainWORKDIR /ng-alainCOPY . .RUN npm run build# STEP 2: Setup// 拷贝nginx配置，ssl配置到nginx中// 拷贝/ng-alain下的dist目录到nginx文件夹// 运行nginx对页面进行代理FROM nginx:1.13.5-alpineCOPY --from=builder /ng-alain/_nginx/default.conf /etc/nginx/conf.d/default.confCOPY --from=builder /ng-alain/_nginx/ssl/* /etc/nginx/ssl/RUN rm -rf /usr/share/nginx/html/*COPY --from=builder /ng-alain/dist /usr/share/nginx/htmlCMD [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] nginx配置配置了端口80，虚拟主机名localhost，主目录/usr/share/nginx/html，首页index.html，错误处理画面50x.html1234567891011121314151617181920212223242526server &#123; listen 80; # listen 443; # ssl on; # ssl_certificate /etc/nginx/ssl/server.crt; # ssl_certificate_key /etc/nginx/ssl/server.key; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; docker compose简单的使用上面的dockerfile进行build，并传入环境变量NODE_ENV:production 结构ng-alain由以下几大模块组成： core layout routes shared core模块core模块首先提供了i18n服务，下面来看ng-alain是如何实现i18n转换的： I18NService实现了AlainI18NService接口，这个接口是这样定义的： 123456export interface AlainI18NService &#123; [key: string]: any; use(lang: string, firstLoad: boolean): void; getLangs(): any[]; fanyi(key: string): any;&#125; 构造方法中调用ngx-translate的addLangs方法来增加可选语言。use方法内设置了ng-zorro的国际化，如果是初次加载时，需要重新刷新页面，也就是重定向到/，use方法的最后，调用了ngx-translate的use方法。这样，就可以使用assets/i18n中的文件，然后利用模板内的translate标识符进行翻译。 123export function HttpLoaderFactory(http: HttpClient) &#123; return new TranslateHttpLoader(http, `assets/i18n/`, &apos;.json&apos;);&#125;. 接下来，core模块实现了http拦截器，通过对HttpInterceptor接口的实现，将错误全部导入handleData方法进行处理，然后根据错误代码导向不同的页面。 最后，core模块制作了一个初始化器，用来加载app内必要的数据。然后设置应用信息，用户信息，初始化菜单等，这期间，调用了@delon theme中的几个服务，例如：MenuService,SettingsService，TitleService，这几个服务将会贯穿整个app的始终。 layout模块layout模块制定了页面布局，也就是以下几个部分： header sidebar passport default: 页面的标准布局 其中，header，sidebar的每一个部分都是一个独立的组件，这两个模块的详细解析放在专门章节解读。 passport模块定义了路由插槽，login,register两个模块可以在passport模块上来回切换。 default页面的布局如下：12345678910&lt;div class="wrapper"&gt; &lt;div class="router-progress-bar" *ngIf="isFetching"&gt;&lt;/div&gt; &lt;app-header class="header"&gt;&lt;/app-header&gt; &lt;app-sidebar class="aside"&gt;&lt;/app-sidebar&gt; &lt;section class="content"&gt; &lt;!-- 引用自@delon/abc/reuse-tab --&gt; &lt;reuse-tab&gt;&lt;/reuse-tab&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/section&gt;&lt;/div&gt; default模块内订阅了router事件，当发生错误时停止router-progress-bar的滚动，100毫秒后隐藏progress-bar，它的css在@delon/theme/styles/app/router-progress-bar.less中。 routes模块routes模块中定义了整个app的路由表和对应的组件，事实上把路由表与组件分开会让src的结构更加清晰。 shared模块将常用模块包装后又导出。跟正常的shared模块的用途一致。]]></content>
      <categories>
        <category>前端</category>
        <category>angular</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>源码</tag>
        <tag>ng-alain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的迭代协议-Sympol.iterator]]></title>
    <url>%2F2016%2F05%2F20%2FES6%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE-Sympol.iterator%2F</url>
    <content type="text"><![CDATA[Array和Map及Set,String有内建的可迭代协议，从chrome上可以看出这一点，所以可以使用各类迭代方法对其中的成员进行访问。 如果要让没有迭代功能的对象具有迭代性，需要实现Sympol.iterator方法。 有以下方式来实现可迭代。 传统方式,缺点是无法使用for-of，只能用next()进行迭代 1234567891011121314151617function Iterator(array)&#123; var nextIndex = 0; return &#123; next: function()&#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;done: true&#125;; &#125; &#125;;&#125;let it = Iterator(['foo', 'bar']);console.log(it.next().value); // 'foo'console.log(it.next().value); // 'bar'console.log(it.next().done); // true Sympol.iterator方式，在这种方式下，没有办法使用类似next()方法来进行迭代 1234567891011121314151617181920212223242526272829const Iterator = &#123; [Symbol.iterator]() &#123; let step = 0; const iterator = &#123; next() &#123; if (step &lt;= 2) &#123; step++; &#125; switch (step) &#123; case 1: return &#123; value: 'foo', done: false &#125;; case 2: return &#123; value: 'bar', done: false &#125;; default: return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; return iterator; &#125;&#125;;// 解构为 foo barconsole.log(...Iterator);// 迭代为 foo barfor(let c of Iterator)&#123; console.log(c);&#125;// 得到 ['f','o','o','b','a','r']Array.from(Iterator); Generator形式，与es6配合最为紧密，支持方法最多 1234567891011121314151617181920function* Iterator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen = Iterator(['foo', 'bar']);// 得到IteratorResult（chrome,firefxo) &#123;value: 'foo', done: false&#125;console.log(gen.next()); console.log(gen.next().value); // bar// 得到 'foo', 'bar'console.log(...Iterator(['foo', 'bar']));// 得到 'foo', 'bar'for(let c of gen)&#123; console.log(c);&#125;// 得到 ['foo', 'bar']Array.from(gen); 另外还有一种无限迭代方式1234567891011function* idMaker()&#123; var index = 0; while(true) yield index++;&#125;var gen = idMaker();console.log(gen.next().value); // '0'console.log(gen.next().value); // '1'console.log(gen.next().value); // '2']]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包模块规范：AMD,Commonjs与ES2015]]></title>
    <url>%2F2016%2F05%2F19%2F%E5%8C%85%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9AAMD%2CCommonjs%E4%B8%8EES2015%2F</url>
    <content type="text"><![CDATA[AMD翻译自amdjs官方wiki 异步模块定义（AMD）API指定了定义模块的机制，以便模块和它的依赖项可以异步加载。这特别适合于浏览器环境，但其中模块的同步加载会导致性能、可用性、调试和跨域访问问题。实现了AMD的，是requirejs。 API定义define(id?, dependencies?, factory); id: 第一个参数id是字符串文字。它指定正在定义的模块的ID。这个参数是可选的，如果它不存在，模块ID应该默认为加载程序请求给定响应脚本的模块的ID。当出现时，模块ID必须是“顶级”或绝对ID（不允许相关ID）。 dependencies: 第二个参数依赖项是模块ID的数组文字，它是被定义的模块所需的依赖项。依赖关系必须在模块工厂函数执行之前解决，并且解析的值应该作为参数传递给工厂函数，参数位置对应于依赖数组中的索引。 factory: 第三个参数，工厂，是实例化模块或对象时应该执行的函数。如果工厂是一个函数，它应该只执行一次。如果工厂参数是一个对象，则应该将该对象分配为模块的导出值。 例子：1234567define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require("beta").verb(); &#125; &#125;); CommonJS以下翻译自webpack官方wiki。 CommonJS组定义一个模块的格式来解决问题以确保JavaScript范围每个模块是在它自己的命名空间执行。 commonjs提供了两个工具来做这件事情： require()方法, 可以使你向当前scope导入模块。 module对象，可以使你从当前scope导出一些东西。 实现了CommonJS的是nodejs,webpack,browserify等。 例子：12345678// moduleA.jsmodule.exports = function( value )&#123; return value*2;&#125;// moduleB.jsvar multiplyBy2 = require('./moduleA');var result = multiplyBy2( 4 ); ES2015ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。对ES2015来说，一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。 模块功能主要由两个命令构成：export和import 例子：12345678910// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;import * as circle from './circle';]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>amd</tag>
        <tag>commonjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs常见坑解决]]></title>
    <url>%2F2016%2F05%2F19%2Fnodejs%E5%B8%B8%E8%A7%81%E5%9D%91%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[node-sass包内安装失败123456npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install node-sass// angular全局安装出错时手动替换node-sassC:\Users\xxxx\AppData\Roaming\npm\node_modules\@angular\cli\node_modules\node-sass\vendor\win32-x64-57\下的binding.node，换成从网上下载的win32-x64-57_binding.node 换源1npm config set registry=https://registry.npm.taobao.org]]></content>
      <categories>
        <category>前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中的新集合类型-map, weakMap,set,weakSet]]></title>
    <url>%2F2016%2F05%2F16%2FES6%E4%B8%AD%E7%9A%84%E6%96%B0%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-map%2CweakMap%2Cset%2CweakSet%2F</url>
    <content type="text"><![CDATA[Mapecma-262 规范中，23节 keyed Collection 对Map有如下定义： Map objects are collections of key/value pairs where both the keys and values may be arbitrary ECMAScript language values. A distinct key value may only occur in one key/value pair within the Map’s collection. Distinct key values are discriminated using the SameValueZero comparison algorithm. Map对象是key-value的集合，key和value可以是es的任意类型。key值具有唯一性，分辨一个key是不是唯一的，使用的是严格比较法。 The Map constructor is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Map behaviour must include a super call to the Map constructor to create and initialize the subclass instance with the internal state necessary to support the Map.prototype built-in methods. Map构造函数被设计成可以继承的，子类可以用extends语句来进行扩展。子类的构造函数在对Map进行继承的时候，必须要包含一个对Map构造函数的super call，这样就可以使用Map.prototype的内置方法。 API Methods：12345678910Map.prototype.clearMap.prototype.deleteMap.prototype.entriesMap.prototype.forEach(callbackfn[,thisArg])Map.prototype.get(key)Map.prototype.has(key)Map.prototype.keysMap.prototype.set(key,value)Map.prototype.sizeMap.prototype.values() key相同的判断： 在内存地址不一样时，值无法被取到1234const map = new Map();map.set([&apos;a&apos;], 1);map.set([&apos;a&apos;], 2);console.log(map.get([&apos;a&apos;])); // 此处的[&apos;a&apos;]的内存地址和之前的都不一样，虽然值相等，仍然get不到值 严格比较法带来的现象12345const map = new Map();map.set(-0, 1);map.get(+0); // 是可以get到的map.set(undfined, 1);map.get(null); // get不到 WeakMapecma-262 规范中，23节 keyed Collection 对WeakMap有如下定义： WeakMap objects are collections of key/value pairs where the keys are objects and values may be arbitrary ECMAScript language values. A WeakMap may be queried to see if it contains a key/value pair with a specific key, but no mechanism is provided for enumerating the objects it holds as keys. If an object that is being used as the key of a WeakMap key/value pair is only reachable by following a chain of references that start within that WeakMap, then that key/value pair is inaccessible and is automatically removed from the WeakMap. WeakMap implementations must detect and remove such key/value pairs and any associated resources. WeakMap对象是key-value的集合，key必须是object（不能是基本数据类型）而value可以是es支持的任意类型。WeakMap可以查询是不是含有特定key，但是没有对key进行枚举的机制。如果一个作为WeakMap的key的object只能被WeakMap自己所引用，那这个key-value pair就会被自动移除。WeakMap的实现必须自主检测这类key-value pair有没有引用者，并及时清除。 API Methods：1234WeakMap.prototype.deleteWeakMap.prototype.getWeakMap.prototype.hasWeakMap.prototype.set 可以看出WeakMap和Map有以下的不同： 由于没有枚举，弱引用的特性，WeakMap只有四个方法delete,get,has,set WeakMap每个键对自己所引用对象的引用是 “弱引用”,GC在计算对象引用数量的时候并不会把弱引用计算进去。这样当一个对象除了WeakMap没有其他引用的时候就会被GC回收掉。 只要没有外部引用， WeakMap只能接受object作为键 WeakMap可以用来避免内存泄漏，存储那些将来可能会消失的对象作为键。 Set &amp; WeakSetecma-262 规范中，23节 keyed Collection 对Set有如下定义：123Set objects are collections of ECMAScript language values. A distinct value may only occur once as an element of a Set&apos;s collection. Distinct values are discriminated using the SameValueZero comparison algorithm.Set objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structures used in this Set objects specification is only intended to describe the required observable semantics of Set objects. It is not intended to be a viable implementation model. Set对象是es任意类型的集合。每个值都都只能出现一次。分辨唯一值用的是严格比较法。 Set实现时采用hash表或是其它机制，提供一种随着集合规模扩大而线性发展的访问原则。Set对象内的数据结构只是用来反映出必要的可观察的语义，而并不是用来作为一种可行的实现模型。 API Methods:1234567Set.prototype.addSet.prototype.clearSet.prototype.deleteSet.prototype.entriesSet.prototype.forEachSet.prototype.has(value)Set.prototype.keys Set.prototype.size Set.prototype.values 特性如同传统编程意义上的Set,和Map类似有key相同判断特性。同样的，WeakSet和WeakMap也有相同的特性，即: 只能add对象而不能是其它原始数据类型 WeakSet对对象的引用是弱引用，所以WeakSet不能枚举，也没有size。 除此之外，以上所说的所有类型，都可以接受可迭代对象作为初始化参数，因为它们都内建了Sympol.iterator方法。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中Object密封API-Object.preventExtensions,Object.seal,Object.freeze]]></title>
    <url>%2F2016%2F05%2F14%2FES6%E4%B8%ADObject%E5%AF%86%E5%B0%81API-Object.preventExtensions%2CObject.seal%2CObject.freeze%2F</url>
    <content type="text"><![CDATA[Object.preventExtensions可以使得一个对象无法添加新属性，但是可以改变原来的属性 用法12345let obj = &#123;foo: 'bar'&#125;;Object.preventExtensions(obj);obj.name = 'test';// undefined，严格模式下报错console.log(obj.test); 另外，Object.isExtensible() 方法可以判断一个对象是否是可扩展的。 Object.seal密封一个对象是让一个对象不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值。 用法12345678'use strict';let obj = &#123;&#125;;Object.defineProperty(obj, 'foo', &#123;writable: true&#125;);let o = Object.seal(obj);o.key = 'fff'; // 增加新属性报错o.foo = 'fff'; // 修改既有属性的值delete o.foo; // 删除既有属性报错Object.defineProperty(obj, 'foo', &#123;writable: false&#125;); // TODO: writable，configurable从true改成false可以，但是不能反过来 另外，Object.isSealed() 方法可以判断一个对象是否是被冻结的。 Object.freeze 用法 Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。1234567let obj = &#123;&#125;;Object.defineProperty(obj, 'foo', &#123;writable: true&#125;);let o = Object.freeze(obj);o.key = 'fff'; // 增加新属性报错o.foo = 'fff'; // 修改既有属性的值delete o.foo; // 删除既有属性报错Object.defineProperty(obj, 'foo', &#123;writable: false&#125;); // TODO: writable，configurable从true改成false可以，但是不能反过来]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中Object常用API-Object.assign,Object.create,Object.defineProperty]]></title>
    <url>%2F2016%2F05%2F10%2FES6%E4%B8%ADObject%E5%B8%B8%E7%94%A8API-Object.assign%2CObject.create%2CObject.defineProperty%2F</url>
    <content type="text"><![CDATA[Object.assign(target, …sources)如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。String类型和Symbol类型的属性都会被拷贝。Object.assign 会跳过那些值为null或undefined的源对象。 用法：1234567var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。 避免浅拷贝 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。123456let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;let obj2 = Object.assign(&#123;&#125;, obj1);obj1.a = 1;obj1.b.c = 1;console.log(obj2) // &#123;a:0, b: &#123;c:1&#125;&#125; 如果要进行深度克隆，就要先创建一个源对象的副本，再进行assign。最简单的写法可能是这样：1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; ployfill 根据emca-262规范内对assign过程的描述，可以对这个方法进行ployfill。 Let to be ? ToObject(target). If only one argument was passed, return to. Let sources be the List of argument values starting with the second argument. For each element nextSource of sources, in ascending index order, do If nextSource is undefined or null, let keys be a new empty List. Else, Let from be ! ToObject(nextSource). Let keys be ? from.[OwnPropertyKeys]. For each element nextKey of keys in List order, do Let desc be ? from.[GetOwnProperty]. If desc is not undefined and desc.[[Enumerable]] is true, then Let propValue be ? Get(from, nextKey). Perform ? Set(to, nextKey, propValue, true). Return to. 123456789101112131415161718192021222324252627282930313233343536373839// 省略前面的对source的判断// function写法Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;;// defineProperty写法Object.defineProperty(Object, "assign", &#123; value: function assign(target, varArgs) &#123; if (target == null) &#123; // TypeError if undefined or null throw new TypeError('Cannot convert undefined or null to object'); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index]; if (nextSource != null) &#123; for (var nextKey in nextSource) &#123; if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, writable: true, configurable: true &#125;); Object.create(proto, propertiesObject) 用法使用Object.create可以很方便的解决继承问题，也可以用extends语法糖解决。 1234567891011121314151617let Parent = &#123; sayWord: function() &#123; return this.word; &#125;&#125;let child = Object.create(Parent, &#123; word: &#123; value: "foo", // writable: true, // configurable: true, // enumerable: true // set // get &#125;&#125;);console.log(child); // &#123;word: foo&#125;/__proto__.sayWord()console.log(child.sayWord()); // foo ployfill If internalSlotsList is not present, set internalSlotsList to a new empty List. Let obj be a newly created object with an internal slot for each name in internalSlotsList. Set obj’s essential internal methods to the default ordinary object definitions specified in 9.1. Set obj.[[Prototype]] to proto. Set obj.[[Extensible]] to true. Return obj.1234567891011121314151617// 来自MDNif (typeof Object.create !== "function") &#123; Object.create = function (proto, propertiesObject) &#123; if (typeof proto !== 'object' &amp;&amp; typeof proto !== 'function') &#123; throw new TypeError('Object prototype may only be an Object: ' + proto); &#125; else if (proto === null) &#123; throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument."); &#125; if (typeof propertiesObject != 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument."); // 实际上还是继承链写法 function F() &#123;&#125; F.prototype = proto; return new F(); &#125;;&#125; Object.defineProperty((bj, prop, descriptor) 用法 123456789101112131415161718192021Object.defineProperty(obj, "key", &#123; enumerable: false, configurable: false, writable: false, value: "static",&#125;);// 写set,get访问器时，不能同时写writable,value属性Object.defineProperty(obj, "key", &#123; enumerable: false, configurable: false, set: function(newValue)&#123; console.log(newValue) // foo value = 'bar'; // value存在于全局变量 &#125;, get: function()&#123; return value; &#125;&#125;);console.log(obj); // &#123;&#125;/key,get,setobj.key = 'foo'console.log(obj.key) // bar 几个属性的意义 writable : 当writable属性设置为false时，不能对这个属性进行赋值运算。严格模式下会报错，普通模式下设置没有作用。 enumerable定义了对象的属性是否可以在for...in循环和Object.keys() 中被枚举。 configurable特性表示对象的属性是否可以被删除，以及除writable特性外的其他特性是否可以被修改。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs中三种方式执行任务流]]></title>
    <url>%2F2016%2F04%2F29%2Fnodejs%E4%B8%AD%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%2F</url>
    <content type="text"><![CDATA[nodejs作为异步平台，有时候也有按顺序执行同步任务的需求。假设有这样一个任务： 首先根据singer去数据库中取ablum,然后从ablum中取song。看以看出，这些任务都是后面依赖前面的，所以传统的异步方法是不行的。有以下三种方法来完成这个任务： Async.parallel使用async库中的方法来完成这个任务：12345678910111213141516171819202122232425function parallelDemo(req, res, next) &#123; async.parallel(&#123; albums: cb =&gt; &#123; restApi.getAblums(singer).then((response) =&gt; &#123; if (response.statusCode !== 200) &#123; return cb('Unable to process ablum request'); &#125; return cb(null, albums); &#125;) &#125;, songs: cb =&gt; &#123; restApi.getSongs(album).then((response) =&gt; &#123; if (response.statusCode !== 200) &#123; return cb('Unable to process song request'); &#125; return cb(null, songs); &#125;) &#125; &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(500).send(err); &#125; return res.json(result); &#125;)&#125; 使用Promise.all12345678910111213141516function parallelDemo(req, res, next) &#123; Promise.all([ getAblums(singer), getSongs(ablum) ]) .then(results =&gt; &#123; let [albums, songs] = results; return res.json(&#123; albums: albums.data, songs: songs.data &#125;); &#125;) .catch(err =&gt; &#123; return res.status(500).send(err); &#125;)&#125; 使用async,await1234567891011121314151617 const processRequest = async () =&gt; &#123; const [posts, albums, photos] = await Promise.all([ getAblums(singer), getSongs(ablum) ]); return &#123; albums: albums.data, songs: songs.data &#125;; &#125;;processRequest() .then(rsp =&gt; &#123; return res.json(rsp); &#125;) .catch(err =&gt; &#123; return res.stats(500).send(err); &#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中的Promise]]></title>
    <url>%2F2016%2F04%2F28%2FES6%E4%B8%AD%E7%9A%84Promise%2F</url>
    <content type="text"><![CDATA[Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 一个 Promise有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 方法123456Promise.all(iterable)Promise.race(iterable)Promise.reject(reason)Promise.resolve(value)Promise.prototype.catch()Promise.prototype.then() Promise.all等待所有代码的完成（或第一个代码的失败）。它的参数是一组iterable。某个值如果不是promise,也会被按顺序计入结果集中。123456789101112131415161718192021let getAblumFromSinger = new Promise((resolve, reject) =&gt; &#123; setTimeout(()=&gt;&#123; console.log("getAblumFromSinger"); &#125;, 1500); resolve("AblumIsHere");&#125;);let getSongFromAblum = new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log("getSongFromAblum"); &#125;, 1000); resolve("SongIsHere");&#125;);let rejectPromise = new Promise((resolve, reject)=&gt;&#123; reject("RejectIsHere");&#125;)Promise.all([getAblumFromSinger,getSongFromAblum]).then(values =&gt; &#123; console.log(values); // 执行上异步，getSongFromAblum比getAblumFromSinger先执行，但是结果是按任务顺序排列的，当promise中有reject时，将会立刻失败&#125;); Promise.prototype.catch如果 onRejected 抛出一个错误或返回一个失败的 Promise ，Promise 通过catch()返回失败结果；否则，它将显示为成功。 Promise.prototype.thenthen() 方法返回一个 Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。 1234567891011Promise.resolve() .then( () =&gt; &#123; // 使 .then() 返回一个 rejected promise throw 'Oh no!'; &#125;) .catch( reason =&gt; &#123; console.error( 'onRejected function called: ', reason ); &#125;) .then( () =&gt; &#123; console.log( "I am always called even if the prior then's promise rejects" ); &#125;); Promise.race(iterable)Promise.race(iterable) 方法返回一个 promise ，并伴随着 promise对象解决的返回值或拒绝的错误原因, 只要 iterable 中有一个 promise 对象”解决(resolve)”或”拒绝(reject)”。1234567891011var p1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, "one"); &#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, "two"); &#125;);Promise.race([p1, p2]).then(function(value) &#123; console.log(value); // "two" // 两个都完成，但 p2 更快，这点与all不同，all会按顺序返回所有的任务结果&#125;); Promise.resolvePromise.reject返回拒绝或接受promise结果]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS居中]]></title>
    <url>%2F2016%2F02%2F05%2FCSS%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[水平居中块级元素（宽度固定）有宽度的前提下，可以设置这个块级元素的左右margin为auto来实现水平居中。 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;div style="height:200px;width:200px;margin-left:auto;margin-right:auto;background-color:red"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 另外，可以利用绝对定位来实现水平居中。首先left:50%，然后再margin到元素宽度一半的地方。12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;&lt;/style&gt;&lt;div class="container"&gt;&lt;div style="position:absolute;left:50%;margin-left:-100px;background-color:red"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 块级元素（宽度不定）没有指定宽度时，可以通过translateX属性来实现。1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.inner&#123;position:absolute;left:50%;transform: translateX(-50%);&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;div class="inner"&gt;这种方法是最不推荐的方法，因为transform属性在各个浏览器中的表现行为不一致，所以会出现一些兼容性的问题，只有当已知用户浏览器时才推荐使用。&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 行内元素块级元素可以通过设置display:inline-block来转换成行内元素来达到相同的效果。设置父容器的text-align为center即可实现行内元素居中。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123; text-align:center;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;span style="background-color:red"&gt;水平居中或者说水平垂直居中的方案很多种,但在实际当中,不一定.....&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex布局设置父容器的flex布局即可实现各类元素水平居中。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123; display:flex; justify-content: center;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;div style="height:200px;width:200px;background-color:red"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 垂直居中行内元素inline 元素的行高与inline-height相等，则中间内容居中。123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123;height:300px;&#125;.inner&#123;line-height:300px;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;span class="inner"&gt;这种方法是最不推荐的方法，因为transform属性在各个浏览器中的表现行为不一致&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以利用inline元素的 CSS 属性 vertical-align，将其设置为 middle，父容器设置为display:table。123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123;display:table;height:300px;&#125;.inner&#123;display:table-cell; vertical-align:middle;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;span class="inner"&gt;这种方法是最不推荐的方法，因为transform属性在各个浏览器中的表现行为不一致&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 块级元素(知道高度)有高度的前提下，可以设置这个块级元素的绝对定位实现垂直居中。123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123;&#125;.inner&#123;position:absolute;height:100px;top:50%;margin-top: -50px;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;div class="inner"&gt;这种方法是最不推荐的方法，因为transform属性在各个浏览器中的表现行为不一致&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 块级元素（高度未知）不知道高度时，与水平对齐同理，可以使用translateY来实现垂直居中。1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123;&#125;.inner&#123;position:absolute;top:50%;tranform:translateY(-50%);&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;div class="inner"&gt;这种方法是最不推荐的方法，因为transform属性在各个浏览器中的表现行为不一致，所以会出现一些兼容性的问题，只有当已知用户浏览器时才推荐使用。&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex布局设置父容器的flex布局即可实现各类元素垂直居中。123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123; height:300px; display:flex; align-items: center;&#125;&lt;/style&gt;&lt;div class="container"&gt;&lt;div&gt;这种方法是最不推荐的方法，因为transform属性在各个浏览器中的表现行为不一致&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS清除浮动]]></title>
    <url>%2F2016%2F02%2F02%2FCSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[首先定义如下几个div。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;.container&#123; border: 1px solid #c5c5c5;&#125;&lt;/style&gt;&lt;div class="container clearfix"&gt;&lt;div id="first" style="width:100px;height:100px;background-color:yellow;float:left;"&gt;&lt;/div&gt;&lt;div style="width:100px;height:200px;background-color:red;float:left"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 此时可以发现，两个div元素行内对齐排列，加了浮动之后的元素脱离了标准流，所以父容器出现了高度塌陷。清除浮动的方法有以下几个： 增加一个空的div元素1&lt;div style="clear:both"&gt;&lt;/div&gt; 为父级元素增加overflow:hidden属性。1234.container&#123; border: 1px solid #c5c5c5; overflow: hidden;&#125; 为父级元素增加伪元素。1234567891011.clearfix:before,.clearfix:after &#123; display: table; content: " ";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL grant命令]]></title>
    <url>%2F2015%2F04%2F20%2FMySQL%20grant%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。 1234grant select on testdb.* to common_user@'%'grant insert on testdb.* to common_user@'%'grant update on testdb.* to common_user@'%'grant delete on testdb.* to common_user@'%' 或者，用一条 MySQL 命令来替代： 1grant select, insert, update, delete on testdb.* to common_user@'%'\ grant 数据库开发人员，创建表、索引、视图、存储过程、函数。。。等权限。 grant 创建、修改、删除 MySQL 数据表结构权限。 123grant create on testdb.* to developer@'192.168.0.%';grant alter on testdb.* to developer@'192.168.0.%';grant drop on testdb.* to developer@'192.168.0.%'; grant 操作 MySQL 外键权限。 1grant references on testdb.* to developer@'192.168.0.%'; grant 操作 MySQL 临时表权限。 1grant create temporary tables on testdb.* to developer@'192.168.0.%'; grant 操作 MySQL 索引权限。 1grant index on testdb.* to developer@'192.168.0.%'; grant 操作 MySQL 视图、查看视图源代码 权限。 12grant create view on testdb.* to developer@'192.168.0.%';grant show view on testdb.* to developer@'192.168.0.%'; grant 操作 MySQL 存储过程、函数 权限。 123grant create routine on testdb.* to developer@'192.168.0.%'; -- now, can show procedure statusgrant alter routine on testdb.* to developer@'192.168.0.%'; -- now, you can drop a proceduregrant execute on testdb.* to developer@'192.168.0.%'; grant 普通 DBA 管理某个 MySQL 数据库的权限。 1grant all privileges on testdb to dba@'localhost' 其中，关键字 privileges 可以省略。 grant 高级 DBA 管理 MySQL 中所有数据库的权限。 1grant all on *.* to dba@'localhost' MySQL grant 权限，分别可以作用在多个层次上。grant 作用在整个 MySQL 服务器上： 12grant select on *.* to dba@localhost; -- dba 可以查询 MySQL 中所有数据库中的表。grant all on *.* to dba@localhost; -- dba 可以管理 MySQL 中的所有数据库 grant 作用在单个数据库上： 1grant select on testdb.* to dba@localhost; -- dba 可以查询 testdb 中的表。 grant 作用在单个数据表上： 1grant select, insert, update, delete on testdb.orders to dba@localhost; 这里在给一个用户授权多张表时，可以多次执行以上语句。例如： 12grant select(user_id,username) on smp.users to mo_user@'%' identified by '123345';grant select on smp.mo_sms to mo_user@'%' identified by '123345'; grant 作用在表中的列上： 1grant select(id, se, rank) on testdb.apache_log to dba@localhost; grant 作用在存储过程、函数上： 12grant execute on procedure testdb.pr_add to 'dba'@'localhost'grant execute on function testdb.fn_add to 'dba'@'localhost' 查看 MySQL 用户权限查看当前用户（自己）权限： 12345show grants;``` 查看其他 MySQL 用户权限：``` sqlshow grants for dba@localhost; 撤销已经赋予给 MySQL 用户权限的权限。revoke 跟 grant 的语法差不多，只需要把关键字 to 换成 from 即可： 12grant all on *.* to dba@localhost;revoke all on *.* from dba@localhost; MySQL grant、revoke 用户权限注意事项 grant, revoke 用户权限后，该用户只有重新连接 MySQL 数据库，权限才能生效。 如果想让授权的用户，也可以将这些权限 grant 给其他用户，需要选项 grant option1grant select on testdb.* to dba@localhost with grant option; 这个特性一般用不到。实际中，数据库权限最好由 DBA 来统一管理。注意：创建完成后需要执行 FLUSH PRIVILEGES 语句。]]></content>
      <categories>
        <category>后端</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
